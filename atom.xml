<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[挂在树上的兔子]]></title>
  <link href="http://blog.yanzl.net/atom.xml" rel="self"/>
  <link href="http://blog.yanzl.net/"/>
  <updated>2017-07-04T23:24:38+08:00</updated>
  <id>http://blog.yanzl.net/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[使用一等函数实现设计模式]]></title>
    <link href="http://blog.yanzl.net/15033291458720.html"/>
    <updated>2017-08-21T23:25:45+08:00</updated>
    <id>http://blog.yanzl.net/15033291458720.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一等函数]]></title>
    <link href="http://blog.yanzl.net/15018651943030.html"/>
    <updated>2017-08-05T00:46:34+08:00</updated>
    <id>http://blog.yanzl.net/15018651943030.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一等对象的定义</h2>

<p>把一等对象定义为满足下述条件的程序实体：</p>

<ul>
<li>在运行时创建</li>
<li>能赋值给变量或者数据结构中的元素</li>
<li>能作为参数传给函数</li>
<li>能作为函数的返回结果</li>
</ul>

<p>在python中，函数也是一等对象，可看如下示例：</p>

<pre><code class="language-Python">def factorial(n):
    &quot;&quot;&quot;
    计算阶乘
    :param n:
    :return:
    &quot;&quot;&quot;
    return 1 if n &lt; 2 else n * factorial(n-1)

print(factorial(3))
print(factorial.__doc__)
x = factorial
print(x(3))
</code></pre>

<h2 id="toc_1">高阶函数的定义</h2>

<p>接收函数为参数，或者吧函数作为返回值的函数就是高阶函数。<br/>
最为人熟知的高阶函数有：<code>map</code>, <code>filter</code>, <code>reduce</code>.</p>

<p><code>reduce</code>在python2中时内置函数，在python3中，放在了functools模块中，这个函数最常用的场景是用来求和，如下示例：</p>

<pre><code class="language-Python">from functools import reduce
from operator import add

print(reduce(add, range(100)))
# 在计算求和方面,sum函数完全可以代替reduce进行计算
print(sum(range(100)))
</code></pre>

<h2 id="toc_2">可调用对象列举</h2>

<ul>
<li>用户定义的函数：使用def语句或者lambda表达式创建的函数。</li>
<li>内置函数：使用C语言实现的内置函数，如<code>len</code>,<code>time.strftime</code>。</li>
<li>内置方法：使用C语言实现的方法，如<code>dict.get</code>。</li>
<li>方法：在类的定义中定义的函数。</li>
<li>类：调用类时会运行类的<code>__new__</code>方法来创建一个实例，然后运行<code>__init__</code>方法，初始化实例，最后把实例返回给调用方。因为Python没有new运算符，所以调用类相当于调用函数。</li>
<li>类的实例：如果定义了<code>__call__</code>方法，那么它的实例可以作为函数调用。</li>
<li>生成器函数：使用<code>yield</code>关键字的函数或方法。调用生成器函数，返回的是生成器对象。</li>
</ul>

<h2 id="toc_3">自定义可调用类型</h2>

<p>任何Python对象都可以表现的像函数，只需要实现实例方法<code>__call__</code>，如下示例所示：</p>

<pre><code class="language-Python">import random


class BingoCage:
    def __init__(self, items):
        self.items = list(items)
        random.shuffle(self.items)

    def pick(self):
        try:
            return self.items.pop()
        except IndexError:
            raise LookupError(&#39;pick from empty BingoCage&#39;)

    def __call__(self):
        return self.pick()

bingo = BingoCage(range(3))
print(bingo.pick())
print(bingo())
print(callable(bingo))
</code></pre>

<h2 id="toc_4">定位参数和仅限关键字参数</h2>

<p>如下示例所示：</p>

<ul>
<li>name是必选参数</li>
<li>cls是可选参数，且只能通过关键字参数传入</li>
<li>name后面的任意个参数，都会被content捕获，存入一个元组中，直到遇到cls参数，或者关键字参数。</li>
<li>关键字参数必须放在参数列表的最后面，当形参中没有对应的关键字时，会被attr参数捕获，存进一个字典中。关键字参数可以传入一个字典，<code>**dic</code>的形式，当形参中含有键名时，会直接赋值，没有对应键名时，会被attr捕获。</li>
</ul>

<pre><code class="language-python">def tag(name, *content, cls=None, **attr):
    print(&quot;this tag name is : {}&quot;.format(name))

    if cls:
        print(&quot;the class name is : {}&quot;.format(cls))

    if content:
        st = &quot;the content is : &quot;
        for c in content:
            st += &quot;{}, &quot;.format(c)
        print(st)

    if attr:
        st = &quot;the style is : &quot;
        for key, value in attr.items():
            st += &quot;{} = {}, &quot;.format(key, value)
        print(st)


tag(&quot;p&quot;, &quot;hello&quot;, &quot;zerol&quot;, cls=&quot;class_p&quot;, id=&quot;p_class&quot;, color=&quot;red&quot;)
tag(&quot;p&quot;, cls=&quot;class_p&quot;, id=&quot;p_class&quot;, color=&quot;red&quot;)
dic = {&quot;cls&quot;: &quot;class_p&quot;, &quot;id&quot;: &quot;p_class&quot;, &quot;color&quot;: &quot;red&quot;}
tag(&quot;p&quot;, **dic)

</code></pre>

<p>仅限关键字参数是Python3新加的特性，上述示例中的cls就是一个仅限关键字参数，实现仅限关键字参数的方法就是把该参数放在前面有*的参数后面，如果函数中不想支持数量不定的定位参数，但想支持仅限关键字参数，则可以直接写个<code>*</code>，如下所示：</p>

<pre><code class="language-python">def f(a, *, b):
    return a, b

print(f(12, b=23))
</code></pre>

<h2 id="toc_5">获取参数信息(inspect.signature的使用)</h2>

<p>函数对象有个<code>__defaults__</code>属性，其值是一个元组，里面保存着定位参数和关键字参数的默认值。仅限关键字参数的默认值在<code>__kwdefaults__</code>属性中。但是这里面仅包含了值，不包含参数名称，具体请看下述示例：</p>

<pre><code class="language-python">def args_info(text, max_len=10, *, kw=17, kw1=23, kw2):

    end = 100
    
    if len(text) &gt; max_len:
        end = len(text)
    else:
        end = max_len

    return end

print(args_info.__defaults__)
print(args_info.__kwdefaults__)
print(args_info.__code__)
print(args_info.__code__.co_varnames)
print(args_info.__code__.co_argcount)

# 代码运行的结果如下：
(10,)
{&#39;kw&#39;: 17, &#39;kw1&#39;: 23}
&lt;code object args_info at 0x1010f4f60, file &quot;6_first_class_function.py&quot;, line 77&gt;
(&#39;text&#39;, &#39;max_len&#39;, &#39;kw&#39;, &#39;kw1&#39;, &#39;kw2&#39;, &#39;end&#39;)
2
</code></pre>

<p>从上述示例可以得出以下结论：</p>

<ul>
<li><code>__defaults__</code>中存放了定位参数和关键字参数的默认值</li>
<li><code>__kwdefaults__</code>中存放了仅限关键字参数的默认值，这是一个字典</li>
<li><code>__code__.co_varnames</code>中不仅存放了定位参数和关键字参数的名字，还存放了仅限关键字参数的名字，以及方法中局部变量的名字。</li>
<li><code>__code__.co_argcount</code>中存放了定位参数和关键字参数的个数。</li>
</ul>

<p>上面的示例中，我们如果想得到参数默认值，必须同时知道参数的个数、名字和值，并且是从后向前对应的。这使用起来会很麻烦，所以用到了<code>inspect</code>模块中的<code>signature</code>方法。</p>

<pre><code class="language-python">from inspect import signature


def args_info_by_signature():
    sig = signature(args_info)
    print(sig)
    str(sig)

    for name, param in sig.parameters.items():
        print(param.kind, &#39;:&#39;, name, &#39;=&#39;, param.default)

args_info_by_signature()

# 代码运行的结果如下：
(text, max_len=10, *, kw=17, kw1=23, kw2)
POSITIONAL_OR_KEYWORD : text = &lt;class &#39;inspect._empty&#39;&gt;
POSITIONAL_OR_KEYWORD : max_len = 10
KEYWORD_ONLY : kw = 17
KEYWORD_ONLY : kw1 = 23
KEYWORD_ONLY : kw2 = &lt;class &#39;inspect._empty&#39;&gt;
</code></pre>

<p>kind属性的值是_ParameterKind类中的5个值之一，这5个值分别是：</p>

<ul>
<li>POSITIONAL_OR_KEYWORD:可以通过定位参数和关键字参数传入的形参</li>
<li>VAR_POSITIONAL:定位形参元组</li>
<li>VAR_KEYWORD:关键字参数字典</li>
<li>KEYWORD_ONLY:仅限关键字参数</li>
<li>POSITIONAL_ONLY:仅限定位参数</li>
</ul>

<p><code>inspect.Signature</code>对象有个<code>bind</code>方法，可以把任意个参数绑定到签名中的形参上，于是可以使用这个方法在真正调用函数前验证参数。</p>

<pre><code class="language-python">def use_bind():
    sig = signature(args_info)
    args = {&#39;text&#39;: &quot;hello,world&quot;, &#39;max_len&#39;: 30, &#39;kw2&#39;: 190}
    bound_args = sig.bind(**args)

    print(bound_args)
    for name, value in bound_args.arguments.items():
        print(name, &#39;=&#39;, value)

    del args[&#39;text&#39;]
    bound_args = sig.bind(**args)

use_bind()

#代码运行的结果如下：
&lt;BoundArguments (text=&#39;hello,world&#39;, max_len=30, kw2=190)&gt;
text = hello,world
max_len = 30
kw2 = 190
Traceback (most recent call last):
  File &quot;6_first_class_function.py&quot;, line 119, in &lt;module&gt;
    use_bind()
  File &quot;6_first_class_function.py&quot;, line 117, in use_bind
    bound_args = sig.bind(**args)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/inspect.py&quot;, line 2921, in bind
    return args[0]._bind(args[1:], kwargs)
  File &quot;/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/inspect.py&quot;, line 2836, in _bind
    raise TypeError(msg) from None
TypeError: missing a required argument: &#39;text&#39;
</code></pre>

<p>可以看到最后程序抛出了参数缺失的错误。这就达到了我们进行参数验证的目的。</p>

<h2 id="toc_6">函数注解</h2>

<pre><code class="language-python">def fun_annotation(test:str, max_len:&#39;int &gt; 0&#39;=80) -&gt; str:
    return &quot;just text&quot;
</code></pre>

<p>上述示例的函数定义中，就用到了函数注解，有注解的函数声明有以下特点：</p>

<ul>
<li>函数声明中的各个参数可以在<code>:</code>之后添加注解表达式</li>
<li>如果参数有默认值，注解的放在参数名和<code>=</code>之间</li>
<li>如果想注解返回值，在<code>)</code>和函数声明末尾的<code>:</code>之间添加<code>-&gt;</code>和一个表达式，该表达式可以是任何类型。</li>
<li>注解中最常用的类型是类（如：str，int）和字符串（如 &#39;int &gt; 0&#39;）</li>
</ul>

<p><strong>注：注解不会做任何处理，python对注解所做的唯一事情是，把他们存储在函数的<code>__annotations__</code>属性里。</strong></p>

<p><code>inspect.signature（）</code>函数可以提取注解，如下所示：</p>

<pre><code class="language-python">def read_annotation():
    sig = signature(fun_annotation)
    print(sig.return_annotation)

    for param in sig.parameters.values():
        note = repr(param.annotation).ljust(13)
        print(note, &#39;:&#39;, param.name, &#39;=&#39;, param.default)

read_annotation()

# 代码运行的结果如下：
&lt;class &#39;str&#39;&gt;
&lt;class &#39;str&#39;&gt; : test = &lt;class &#39;inspect._empty&#39;&gt;
&#39;int &gt; 0&#39;     : max_len = 80
</code></pre>

<h2 id="toc_7">支持函数式编程的包</h2>

<h3 id="toc_8">functools.partial</h3>

<pre><code class="language-python">from operator import mul
from functools import partial

triple = partial(mul, 3)
print(triple(7))
</code></pre>

<p>partial的第一个参数是一个可调用对象，后面跟着任意个要绑定的定位参数或者关键字参数。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文本和字节序列]]></title>
    <link href="http://blog.yanzl.net/15018646605864.html"/>
    <updated>2017-08-05T00:37:40+08:00</updated>
    <id>http://blog.yanzl.net/15018646605864.html</id>
    <content type="html"><![CDATA[
<p>写在前面：这篇笔记只是简单地记录一下，因为对编码问题了解的比较少，所以在看的过程中并不算太懂，这里只把能够理解的以及应该记忆的列举出来。</p>

<h2 id="toc_0">字符</h2>

<p>字符的标识，即码位，是0~1114111的数字。<br/>
字符的具体表述取决于编码，编码是在码位和字节序列之间转换时的算法。<br/>
把码位转换成字节序列的过程是编码，把字节序列转换成码位的过程是解码。简单粗暴的来说，编码就是把人类可读的文本字符串转换成传输需要的字节序列，解码就是把字节序列转换成人类可读的本文字符串。</p>

<h2 id="toc_1">字节</h2>

<p>二进制序列各个字节的值可能会使用下列三种不同的方式展示：</p>

<ul>
<li>可打印的ASCII范围内的字节，使用ASCII字符本身。</li>
<li>制表符、换行符、回车符和\对应的字节，使用转义序列\t、\n、\r和\</li>
<li>其它字节的值使用十六进制转义序列（例如 \x00是空字节）</li>
</ul>

<h3 id="toc_2">构建bytes 和 bytearray实例</h3>

<p>构建bytes 和 bytearray实例可以调用各自的构造方法，传入一下参数</p>

<ul>
<li>一个str对象和一个encoding关键字参数</li>
<li>一个可迭代对象，提供0~255之间的数值</li>
<li>一个实现了缓冲协议的对象（如：bytes, bytearray, memoryview, array.array()）;此时，把源对象中的字节序列复制到新建的二进制序列中</li>
</ul>

<h2 id="toc_3">处理UnicodeEncodeError</h2>

<p>多数非UTF编解码器只能处理Unicode字符的一小部分，当我们把文本转换成字节序列时，如果目标编码中没有定义某个字符，就会抛出UnicodeEncodingError异常，除非把errors参数传给编码方法或函数。就像示例一样。</p>

<pre><code class="language-python">city = &#39;São Paulo&#39;
print(city.encode(&#39;utf_8&#39;))

print(city.encode(&#39;utf_16&#39;))

print(city.encode(&#39;iso8859_1&#39;))

print(city.encode(&#39;cp437&#39;))
</code></pre>

<p>上述示例在运行到最后一个<code>print</code>语句的时候，程序会抛出UnicodeEncodeError，然后终止运行。如果希望程序能够自己解决这种编码问题。可以传递errors参数,告诉程序遇到无法编码的字符时的处理方法，如下面示例：</p>

<pre><code class="language-python">city = &#39;São Paulo&#39;

print(city.encode(&#39;cp437&#39;, errors=&#39;ignore&#39;))

print(city.encode(&#39;cp437&#39;, errors=&#39;replace&#39;))

print(city.encode(&#39;cp437&#39;, errors=&#39;xmlcharrefreplace&#39;))
</code></pre>

<p>上面示例的errors参数中的值都是已经注册好的，该参数的默认值是“strict”，该默认值的意思是直接抛出异常。另外，当遇到编码错误时，还可以使用自己注册的额外的字符串，方法是把一个名称和一个错误处理函数传给<code>codecs.register_error</code>函数。</p>

<h2 id="toc_4">处理UnicodeDecodeError</h2>

<p>不是每个字节都包含有效的ASCII字符，也不是每一个字符序列都是有效的UTF_8或UTF_16,当把二进制序列转换成文本时，如果是这两个编码中的一个，遇到无法转换的字节序列时，程序会抛出UnicodeDecodeError错误。</p>

<pre><code class="language-python">octet = b&#39;Montr\xe9al&#39;
print(octet.decode(&#39;cp1252&#39;))

print(octet.decode(&#39;iso8859_7&#39;))

print(octet.decode(&#39;koi8_r&#39;))

print(octet.decode(&#39;utf_8&#39;))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[集合的使用]]></title>
    <link href="http://blog.yanzl.net/15013419653919.html"/>
    <updated>2017-07-29T23:26:05+08:00</updated>
    <id>http://blog.yanzl.net/15013419653919.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">集合和运算</h2>

<ul>
<li>集合的本质是许多唯一对象的聚集，因此，集合可以用来去重。</li>
</ul>

<pre><code class="language-python">l = [&#39;ABC&#39;, &#39;abc&#39;, &#39;ABC&#39;, &#39;def&#39;]
print(set(l))
</code></pre>

<ul>
<li>集合中的元素必须是散列的</li>
<li>集合实现了很多中缀运算符，比如<code>a | b</code>代表求a和b的合集，<code>a &amp; b</code>代表求a和b的交集，<code>a - b</code>代表a和b的差集（属于a但是不属于b的元素组成的集合叫做a和b的差集）。</li>
</ul>

<pre><code class="language-python">l1 = {&#39;ABC&#39;, &#39;AYU&#39;}
l2 = {&#39;ABC&#39;, &#39;DEF&#39;, &#39;abc&#39;, &#39;XYZ&#39;}
print(l1 &amp; l2)
# l1 和 l2的差集
print(l1 - l2)
# l2 和 l1 的差集
print(l2 - l1)
</code></pre>

<h2 id="toc_1">集合字面量</h2>

<p>集合的空集表示成：<code>set()</code><br/>
集合其他形式的字面量展现为： <code>{1}, {1, 2}</code></p>

<h2 id="toc_2">集合推导</h2>

<p>和列表推导、字典推导一样，集合也可以通过集合推导的方式构建一个新的集合<br/>
每一个字符都有自己的名字，下面的示例就是将名字中含有”SIGN“的字符构建一个集合，然后将这些字符的名字构成一个集合。</p>

<pre><code class="language-python">from unicodedata import name
l3 = {chr(i) for i in range(32, 256) if &#39;SIGN&#39; in name(chr(i), &#39;&#39;)}
l4 = {name(chr(i)) for i in range(32, 256) if &#39;SIGN&#39; in name(chr(i), &#39;&#39;)}
print(l3)
print(l4)
</code></pre>

<h2 id="toc_3">集合的操作</h2>

<h3 id="toc_4">集合的数学运算</h3>

<table>
<thead>
<tr>
<th>数学符号</th>
<th>Python运算符</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>S ∩ Z</td>
<td>s &amp; z</td>
<td><code>s.__and__(z)</code></td>
<td>s 和 z 的交集</td>
</tr>
<tr>
<td>S ∩ Z</td>
<td>z &amp; s</td>
<td><code>s.__rand__(z)</code></td>
<td>反向 &amp; 操作</td>
</tr>
<tr>
<td>S ∩ Z</td>
<td></td>
<td><code>s.intersection(it, ...)</code></td>
<td>把可迭代的it和其他所有参数转化为集合，然后求他们与s的交集</td>
</tr>
<tr>
<td>S ∩ Z</td>
<td>s &amp;= z</td>
<td><code>s.__iand__(z)</code></td>
<td>把s更新为s和z的交集</td>
</tr>
<tr>
<td>S ∩ Z</td>
<td></td>
<td><code>s.intersection_update(it, ...)</code></td>
<td>把可迭代的it和其他所有参数转化为集合，然后求他们与s的交集，然后把s更新为这个交集</td>
</tr>
<tr>
<td>S ∪ Z</td>
<td>s <code>|</code> z</td>
<td><code>s.__or__(z)</code></td>
<td>s和z的并集</td>
</tr>
<tr>
<td>S ∪ Z</td>
<td>z <code>|</code> s</td>
<td><code>s.__ror__(z)</code></td>
<td>并集的反向操作</td>
</tr>
<tr>
<td>S ∪ Z</td>
<td></td>
<td><code>s.union(it, ...)</code></td>
<td>把可迭代的it和其他所有参数转化为集合，然后求他们与s的并集</td>
</tr>
<tr>
<td>S ∪ Z</td>
<td>s <code>|=</code> z</td>
<td><code>s.__ior__(z)</code></td>
<td>把s更新为s和z的并集</td>
</tr>
<tr>
<td>S ∪ Z</td>
<td></td>
<td><code>s.update(it, ...)</code></td>
<td>把可迭代的it和其他所有参数转化为集合，然后求他们与s的并集，并把s更新为这个并集</td>
</tr>
<tr>
<td>S \ Z</td>
<td>s - z</td>
<td><code>s.__sub__(z)</code></td>
<td>s 和 z的差集，或者叫做相对补集</td>
</tr>
<tr>
<td>S \ Z</td>
<td>z - s</td>
<td><code>s.__rsub__(z)</code></td>
<td>差集的反向操作</td>
</tr>
<tr>
<td>S \ Z</td>
<td></td>
<td><code>s.difference(it, ...)</code></td>
<td>把可迭代的it和其他所有参数转化为集合，然后求他们与s的差集</td>
</tr>
<tr>
<td>S \ Z</td>
<td>s -= z</td>
<td><code>s.__isub__(z)</code></td>
<td>把s更新为它与z的差集</td>
</tr>
<tr>
<td>S \ Z</td>
<td></td>
<td><code>s.difference_update(it, ...)</code></td>
<td>把可迭代的it和其他所有参数转化为集合，然后求他们与s的差集，并把s更新成这个差集</td>
</tr>
<tr>
<td>S △ Z</td>
<td></td>
<td><code>s.symmetric_difference(it)</code></td>
<td>求s和set（it）的对称差集</td>
</tr>
<tr>
<td>S △ Z</td>
<td>s ^ z</td>
<td><code>s.__xor__(z)</code></td>
<td>求s和z的对称差集</td>
</tr>
<tr>
<td>S △ Z</td>
<td>z ^ s</td>
<td><code>s.__rxor__(z)</code></td>
<td>对称差集的反向操作</td>
</tr>
<tr>
<td>S △ Z</td>
<td></td>
<td><code>s.symmetric_difference_update(it, ...)</code></td>
<td>把可迭代的it和其他所有参数转化为集合，然后求他们与s的对称差集，然后把s更新成这个对称差集</td>
</tr>
<tr>
<td>S △ Z</td>
<td>s <sup>=</sup> z</td>
<td><code>s.__ixor__(z)</code></td>
<td>把s更新成它与z的对称差集</td>
</tr>
</tbody>
</table>

<h3 id="toc_5">集合的比较运算符，返回值是布尔类型</h3>

<table>
<thead>
<tr>
<th>数学符号</th>
<th>Python运算符</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td></td>
<td></td>
<td><code>s.isdisjoint(z)</code></td>
<td>查看s和z是否不相交（没有共同元素）</td>
</tr>
<tr>
<td>e ∈ s</td>
<td>e in s</td>
<td><code>s.__contains__(e)</code></td>
<td>元素e是否属于s</td>
</tr>
<tr>
<td>S ⊆ Z</td>
<td>s &lt;= z</td>
<td><code>s.__le__(z)</code></td>
<td>s 是否为 z 的子集</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>s.issubset(it)</code></td>
<td>把可迭代的it转换为集合，然后查看s是否是它的子集</td>
</tr>
<tr>
<td>S ⊂ Z</td>
<td>s &lt; z</td>
<td><code>s.__lt__(z)</code></td>
<td>s 是否为 z 的真子集</td>
</tr>
<tr>
<td>S ⊇ Z</td>
<td>s &gt;= z</td>
<td><code>s.__ge__(z)</code></td>
<td>s 是否为 z 的父集</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>s.issuperset(it)</code></td>
<td>把可迭代的it转换为集合，然后查看s是否是它的父集</td>
</tr>
<tr>
<td>S ⊃ Z</td>
<td>s &gt; z</td>
<td><code>s.__gt__(z)</code></td>
<td>s 是否为 z 的真父集</td>
</tr>
</tbody>
</table>

<h3 id="toc_6">集合类型的其他方法</h3>

<table>
<thead>
<tr>
<th>方法</th>
<th>set</th>
<th>frozenset</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>s.add(e)</code></td>
<td>✅</td>
<td></td>
<td>把元素e添加到集合s中</td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>✅</td>
<td></td>
<td>清空s集合</td>
</tr>
<tr>
<td><code>s.copy()</code></td>
<td>✅</td>
<td>✅</td>
<td>对s进行浅复制</td>
</tr>
<tr>
<td><code>s.discard(e)</code></td>
<td>✅</td>
<td></td>
<td>如果s中有e这个元素，则将其移除</td>
</tr>
<tr>
<td><code>s.__iter__()</code></td>
<td>✅</td>
<td>✅</td>
<td>返回s的迭代器</td>
</tr>
<tr>
<td><code>s.__len__()</code></td>
<td>✅</td>
<td>✅</td>
<td><code>len(s)</code></td>
</tr>
<tr>
<td><code>s.pop()</code></td>
<td>✅</td>
<td></td>
<td>从s中移除一个元素，并返回它的值，若s为空，则抛出KeyError异常</td>
</tr>
<tr>
<td><code>s.remove(e)</code></td>
<td>✅</td>
<td></td>
<td>从s中移除e元素，若e元素不存在，则抛出KeyError异常</td>
</tr>
</tbody>
</table>

<h2 id="toc_7">字典中的散列表</h2>

<p>散列表其实是一个稀疏数组，散列表的单元通常叫做表元。Python会设法保证大概有三分之一的表元是空的，所以在快要达到这个阙值的时候，会将所有的散列表复制到一个更大的空间。<br/>
在dict的散列表中，一个表元包含两部分，一个是键的引用，一个是值的引用，因为都是引用，所以表元的大小都是一致的，从而实现了通过偏移量读取表元。</p>

<h3 id="toc_8">散列值和相等性</h3>

<p>如果要将一个元素放进散列表中，则必须计算这个元素的散列值，内置的<code>hash()</code>可以用于所有的内置类型对象，也可以自己实现<code>__hash__()</code>方法，要保证的是如果两个对象在比较的时候是相等的，则其散列值必须相同。</p>

<h3 id="toc_9">散列表算法</h3>

<p>从字典中取值的算法流程图如下所示：</p>

<p><img src="http://cdn.blog.yanzl.net/2017-07-30-hash_search.png" alt=""/></p>

<ul>
<li>首先，python会调用<code>hash(search_key)</code>来计算search_key的散列值，然后把这个值最低的几位数字当做偏移量。</li>
<li>根据计算出来的偏移量查找对应的表元</li>
<li>如果表元不存在则抛出KeyError异常</li>
<li>如果表元存在，则表元中会存在found_key:found_value,python会验证表元中的found_key是否和search_key相等，如果想等则返回found_value。</li>
<li>如果<code>found_kay != search_key</code>，则发生了散列冲突，利用解决冲突的方法计算出下一个表元的位置，再次判断表元首否为空，直到抛出KeyError异常或者找到这个元素所在的表元为止。</li>
</ul>

<h4 id="toc_10">关于散列冲突</h4>

<p>散列表所做的其实是把随机的元素映射到只有几位的数字上，而散列表本身的索引依赖于这个数字的一部分，为了解决散列冲突，算法会在散列值中另外再取几位，然后用特殊的方法处理一下，把新得到的数字在当做索引来寻找表元。</p>

<h3 id="toc_11">dict的实现及其导致的结果</h3>

<h4 id="toc_12">键必须是可散列的</h4>

<p>一个可散列的对象必须满足以下要求：</p>

<ul>
<li>支持<code>hash()</code>函数，并且通过<code>__hash__()</code>所得到的散列值是不变的</li>
<li>支持通过<code>__eq__()</code>方法来检测性等性</li>
<li>若<code>a == b</code>为真，则<code>hash(a) == hash(b)</code>也为真</li>
</ul>

<h4 id="toc_13">字典在内存上的开销巨大</h4>

<p>具体原因上面已经提到过，散列表是稀疏数组，空间的利用率比较低。因此，如果要存放数量巨大的对象，使用元组或者命名元组是比较好的选择，这样做一方面能够避免散列表所消耗的空间，另一方面也无需记录中字段的名字在每个元素里都存一遍。</p>

<h4 id="toc_14">键查询很快</h4>

<p>字典的实现就是用空间换时间，虽然字典在内存上的开销很大，但查询速度也是非常快的。</p>

<h4 id="toc_15">键的次序取决于添加顺序</h4>

<p>当往字典中添加新建而又发生散列冲突的时候，新建可能会被安排到另一个新的位置，这会造成以不同元素顺序存入的两个字典，在存储过程中如果发生了散列冲突，则字典是相等的，但是键在字典中出现的顺序是不一样的。</p>

<h4 id="toc_16">往字典中添加新键可能会改变已有键的顺序</h4>

<p>在往字典中添加新的元素时，字典会启动是否需要扩容的判断，在扩容执行的时候，可能会发生新的散列冲突，导致原有的键的顺序发生了变化。</p>

<h3 id="toc_17">set的实现及其导致的结果</h3>

<p>set 和 frozenaet的实现也依赖于散列表，只是表元中存储的只有元素的引用，其特点和上面提到的字典的特点是一样的，总结如下：</p>

<ul>
<li>集合中的元素必须是可散列的</li>
<li>集合很消耗内存</li>
<li>集合可以很高效地判断元素是否存在于某个集合中</li>
<li>元素的次序取决于被添加到集合中的次序</li>
<li>忘记何种添加元素，可能会改变集合中已有的元素的次序</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字典的使用]]></title>
    <link href="http://blog.yanzl.net/15010832436363.html"/>
    <updated>2017-07-26T23:34:03+08:00</updated>
    <id>http://blog.yanzl.net/15010832436363.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">可散列的数据类型</h2>

<h3 id="toc_1">定义</h3>

<p>如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现<code>__hash()__</code>方法。<br/>
另外，可散列对象还要有<code>__qe()__</code>方法，这样才能跟其他键作比较。<br/>
如果两个可散列对象是相等的，那么它们的散列值一定是一样的。</p>

<h3 id="toc_2">可散列数据举例</h3>

<ul>
<li>str,bytes和数值类型等原子不可变数据类型都是可散列的类型。</li>
<li>对于元组来说，只有当一个元组包含的所有元素都是可散列类型的情况下，该元组才是可散列类型。</li>
<li>自定义对象都是可散列的，散列值就是该对象的id()函数返回的值</li>
</ul>

<h2 id="toc_3">字典的构造方法</h2>

<p>构造字典的方式有很多种，如下所示：</p>

<pre><code class="language-python"># 字典的构造方法
dict1 = {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 23, &quot;email&quot;: &quot;test@126.com&quot;}
dict2 = dict(name=&quot;Alice&quot;, age=23, email=&quot;test@126.com&quot;)
dict3 = dict([(&quot;name&quot;, &quot;Alice&quot;), (&quot;age&quot;, 23), (&quot;email&quot;, &quot;test@126.com&quot;)])
dict4 = dict(zip([&quot;name&quot;, &quot;age&quot;, &quot;email&quot;], [&quot;Alice&quot;, 23, &quot;test@126.com&quot;]))
dict5 = dict({&quot;email&quot;: &quot;test@126.com&quot;, &quot;age&quot;: 23, &quot;name&quot;: &quot;Alice&quot;})

print(dict1 == dict2 == dict3 == dict4 == dict5)
</code></pre>

<p>这个示例的输出结果会是<code>True</code>，由此可以看出,无论我们用什么方法、以什么顺序创造字典,在基本的字典类型中,只要字典中元素的键和值都是相等的,创造出来的字典都是相同的。</p>

<h3 id="toc_4">字典推导(ﾉ*･ω･)ﾉ</h3>

<p>和列表一样,字典也可以使用字典推导的方法来构建新的字典,来看下面两个例子：</p>

<pre><code class="language-Python"># 示例一
dial_codes = [(86, &#39;China&#39;), (91, &#39;India&#39;), (1, &#39;Unit States&#39;), (62, &#39;Indonesia&#39;), (55, &#39;Brazil&#39;), (92, &#39;Pakistan&#39;),
              (880, &#39;Bangladesh&#39;), (234, &#39;Nigeria&#39;), (7, &#39;Russia&#39;), (81, &#39;Japan&#39;)]
country_code1 = {country: code for code, country in dial_codes}
print(country_code1)
</code></pre>

<pre><code class="language-python"># 示例二
codes = [86, 91, 1, 62, 55, 92, 880, 234, 7, 81]
countries = [&quot;China&quot;, &quot;India&quot;, &quot;Unit States&quot;, &quot;Indonesia&quot;, &quot;Brazil&quot;, &quot;Pakistan&quot;, &quot;Bangladesh&quot;, &quot;Nigeria&quot;, &quot;Russia&quot;,
             &quot;Japan&quot;]
country_code2 = {country: code for country in countries for code in codes}
country_code3 = [{country: code} for country in countries for code in codes]
print(country_code2)
print(country_code3)
</code></pre>

<p>在示例二中,给出了两种推导的方法,一种是字典推导,会得到一个字典,另一种是列表推导,该示例和1_magic_method.py中生成纸牌的示例很相似,这里计算的是codes和countries的笛卡尔积。可以自己运行程序查看结果。</p>

<p><strong>注：示例二中字典推导的结果和示例一中字典推导的结果是不一样的，示例一是正常的一个代号对应一个国家的字典展示，示例二中country_code2是country_code3的一部分，即一个代号对应的所有国家的结果</strong></p>

<h2 id="toc_5">常见的映射方法</h2>

<p>collections模块中有两个字典的变种类型，分别是defaultdict和OrderedDict，它们和dict类型也是有共同的方法。具体可以看下表的内容：</p>

<table>
<thead>
<tr>
<th>方法列表</th>
<th>dict</th>
<th>defaultdict</th>
<th>OrderedDict</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>d.clear()</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>移除所有的元素</td>
</tr>
<tr>
<td><code>d.__contains__(k)</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>检查k是否在d中</td>
</tr>
<tr>
<td><code>d.copy()</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>浅复制</td>
</tr>
<tr>
<td><code>d.__copy__()</code></td>
<td></td>
<td>✅</td>
<td></td>
<td>用于支持浅复制</td>
</tr>
<tr>
<td><code>d.default_factory</code></td>
<td></td>
<td>✅</td>
<td></td>
<td>在<code>__mising__</code>函数中被调用的函数，用于给未找到的元素设置值</td>
</tr>
<tr>
<td><code>d.__delitem__(k)</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td><code>del d(k)</code>, 移除键为k的元素</td>
</tr>
<tr>
<td><code>d.fromkeys(it, [initial])</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>将迭代器it里的元素设置为映射里的键， 如果有initial参数，就把它设为这些键对应的值，默认为None</td>
</tr>
<tr>
<td><code>d.get(k, [default])</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>返回键k对应的值，如果字典中没有该键，则返回default的值或者None</td>
</tr>
<tr>
<td><code>d.__getitem__(k)</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>让字典d能用<code>d[k]</code>的形式返回k对应的值，如果k找不到会报错</td>
</tr>
<tr>
<td><code>d.items()</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>返回d中所有的键值对</td>
</tr>
<tr>
<td><code>d.__iter__()</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>返回键的迭代器</td>
</tr>
<tr>
<td><code>d.keys()</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>返回字典的所有键</td>
</tr>
<tr>
<td><code>d.__len__()</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>可以使用<code>len(d)</code>的形式得到字典的键值对数量</td>
</tr>
<tr>
<td><code>d.__missing__(k)</code></td>
<td></td>
<td>✅</td>
<td></td>
<td>当<code>__getitem__()</code>找不到相应的值时，会调用该方法</td>
</tr>
<tr>
<td><code>d.move_to_end(k, [last])</code></td>
<td></td>
<td></td>
<td>✅</td>
<td>把键为k的元素移动到字典的最前面或者最后面， last默认为True</td>
</tr>
<tr>
<td><code>d.pop(k, [default])</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>返回键k所对应的值，然后移除这个键值对，如果k没有找到，则返回default的值或者None</td>
</tr>
<tr>
<td><code>d.popitem()</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>随机返回一个键值对，并在字典中移除掉</td>
</tr>
<tr>
<td><code>d.__reversed__()</code></td>
<td></td>
<td></td>
<td>✅</td>
<td>返回倒序的键的迭代器</td>
</tr>
<tr>
<td><code>d.setdefault(k, [default])</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>若字典中有键k，则把它对应的值设定为default的值，然后返回这个值若无，则让<code>d[k] = default</code>，然后返回default</td>
</tr>
<tr>
<td><code>d.__setitem__(k, v)</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>实现d[k] = v的操作</td>
</tr>
<tr>
<td><code>d.update(m, [**kargs])</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>m可以是映射或者键值对迭代器，用来更新d中对应的条目</td>
</tr>
<tr>
<td><code>d.values()</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>返回字典中的所有值</td>
</tr>
</tbody>
</table>

<h2 id="toc_6">处理找不到的键的方法</h2>

<p>从上面的表中可以得知，查找一个字典的键对应的值有多种方法</p>

<ul>
<li><code>d[k]</code>方法在找不到键k时，Python会直接抛出异常</li>
<li><code>d.get(k, [default])</code> 方法在找不到键k时，会返回None, 如果default参数被设定了，则会返回该参数的值</li>
</ul>

<h3 id="toc_7">使用setdefault</h3>

<p>如果除了拿到这个值外，还想对该值进行更新操作，并且在没有键的情况下，则执行添加操作，那么setdefault方法是最好的选择</p>

<p><code>d.setdefault()</code>方法的使用十分简单，下面来看使用这个方法和不使用的代码对比：</p>

<pre><code class="language-python"># 从字典country_code1中搜索Korea对应的号码, 如果没有则赋值为99999
import time
start_time = time.time()
if &quot;Korea&quot; not in country_code1:
    country_code1[&quot;Korea&quot;] = 99999
    print((time.time() - start_time)*10000)

# 从字典country_code1中搜索Canada对应的号码, 如果没有则赋值为251
start_time = time.time()
country_code1.setdefault(&quot;Canada&quot;, 251)
print((time.time() - start_time)*10000)
print(country_code1)
</code></pre>

<p>在上述示例中，计算出了两种方法的执行时间，从时间来看，使用<code>setdefault()</code>方法所用的时间会更短。</p>

<h3 id="toc_8">自定义__missing__方法</h3>

<p>如果只是单纯的查找取值，除了<code>d[k]</code> 和 <code>d.get(k, [default])</code> 两种方法，defaultdict类型还提供了<code>__missing__</code>方法。</p>

<p>defaultdict类型的基本使用示例：</p>

<pre><code class="language-python">import collections
dd = collections.defaultdict(tuple, **country_code1)
print(dd[&#39;China&#39;])
print(dd.get(&quot;C&quot;))
print(dd[&quot;C&quot;])
print(dd[&quot;B&quot;])
print(dd.get(&quot;B&quot;))
</code></pre>

<p>从上示例的结果可以看出，当从字典中查询一个不存在的键时，defaultdict会对该键初始化一个空的tuple作为值，之后在查询该键，则会返回空的tuple。<br/>
并且，<code>__missing__</code>方法只会在<code>__getitem__</code>里被调用，其他方法是不会发挥作用的。</p>

<p>如果觉得defaultdict中的<code>__missing__</code>太有局限性了，可以自己定义一个雷然后实现该方法，从而达到目的。<br/>
比如以下示例：</p>

<pre><code class="language-Python">class StrKeyDict0(dict):

    def __missing__(self, key):
        if isinstance(key, str):
            raise KeyError(key)
        return self[str(key)]

    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default

    def __contains__(self, item):
        return item in self.keys() or str(item) in self.keys()

d = StrKeyDict0([(&#39;2&#39;, &#39;two&#39;), (&#39;4&#39;, &#39;four&#39;)])
print(d[&#39;2&#39;])
print(d[4])
print(d.get(&#39;2&#39;))
print(d.get(4))
print(d.get(1))
print(2 in d)
print(1 in d)
print(d[1])
</code></pre>

<p>自定义类实现的功能是当请求的键是其他类型时，转换成字符串类型再去获取值。该类的实现有以下几点值得注意：</p>

<ul>
<li>get()方法把查找的工作以<code>self[key]</code>的形式进行处理，这样做可以在取值的时候调用<code>__getitem__()</code>方法，当获取不到键的时候，该方法会去调用<code>__missing__()</code>方法，于是就会触发将键的类型转换成字符串形式的操作。</li>
<li>关于<code>__missing__()</code>方法中为什么还要判断key的类型是否是字符串，则是为了防止掉进无限递归的陷阱。<code>__missing__()</code>方法的返回还是使用<code>self[key]</code>的格式，该方法在获取不到键的时候会调用<code>__missing__()</code>方法，因此会形成一个无限递归。</li>
<li>关于为什么会有<code>__contains__</code>方法，是因为在执行<code>in</code>操作的时候会用到该方法，但是dict中提供的这个方法不会在找不到键的时候调用<code>__missing__</code>方法。另外，在实现这个方法的时候，使用的是<code>key in self.keys()</code>的形式而不是<code>key in d</code>的形式，也是为了防止掉进无限递归的陷阱中。</li>
</ul>

<h2 id="toc_9">字典的变种</h2>

<p>标准库collections模块中，有以下几种不同的映射类型：</p>

<ul>
<li>collections.OrderedDict</li>
<li>collections.ChainMap</li>
<li>collections.Counter</li>
<li>collections.UserDict</li>
</ul>

<p>除此之外，Python3.3之后，types模块引入了一个封装类名叫<code>MappingProxyType</code>的不可变映射类型。如果给这个类一个映射，他会返回一个只读视图，但是这个视图也是动态的。因此可以直接对原映射做出改变，但是不能通过视图对原映射做出改变。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[列表的使用]]></title>
    <link href="http://blog.yanzl.net/15008213108914.html"/>
    <updated>2017-07-23T22:48:30+08:00</updated>
    <id>http://blog.yanzl.net/15008213108914.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">序列</h2>

<p>按照存放的数据，序列可以分为容器序列和扁平序列，区别在于容器序列存放的是他们所包含的任意类型的对象的引用，扁平序列存放的是值，因此扁平序列其实是一段连续的内存空间，但是扁平序列只能存放像字符，字节和数值这种基本类型。容器序列和扁平序列的举例如下：</p>

<ul>
<li>容器序列： list, tuple, collections.deque</li>
<li>扁平序列： str, bytes, bytearray, array.array</li>
</ul>

<p>按照存放数据能否被修改可以分为可变序列和不可变序列，顾名思义，可变序列就是存放的数值是可以被改变的，不可变序列就是值是不可以被改变的，如果被改变了，将会得到一个新的对象。可变序列和不可变序列的举例如下：</p>

<ul>
<li>可变序列： list, bytearray, array.array, collections.deque, memoryview</li>
<li>不可变序列： tuple, str, bytes</li>
</ul>

<h2 id="toc_1">列表推导</h2>

<p>列表推导是构建列表的快捷方式。废话不多说，直接上列表推导的示例：</p>

<pre><code class="language-Python">def symbol2ascii(symbols):
    ascii_codes = [ord(symbol) for symbol in symbols]
    print(ascii_codes)


symbol2ascii(&quot;ABCDabcdEF&quot;)
</code></pre>

<p>列表推导虽然可读性更好，代码运行更高效，但也不能够滥用，如果列表推导的代码超过了两行，就应该考虑使用for循环代替了。一般的原则是：只用列表推导来创建新的列表，并且尽量保持简短。</p>

<h2 id="toc_2">生成器表达式</h2>

<p>列表推倒的作用只是生成列表，如果希望生成其他类型的序列，可以使用生成器表达式，它能够创建其它任何类型的序列。另外，生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。<br/>
生成器表达式的语法和列表很相似，不同之处是把方括号换成圆括号，并指明要生成的序列类型。</p>

<pre><code class="language-Python">def symbol2ascii_by_generator(symbols):
    ascii_codes_generator = (ord(symbol) for symbol in symbols)
    ascii_codes_tuple = tuple(ord(symbol) for symbol in symbols)
    ascii_codes_list = list(ord(symbol) for symbol in symbols)
    print(type(ascii_codes_generator))
    print(type(ascii_codes_tuple))
    print(type(ascii_codes_list))
    
symbol2ascii_by_generator(&quot;ABCDabcdEF&quot;)
</code></pre>

<h2 id="toc_3">切片</h2>

<h3 id="toc_4">为什么切片和区间会忽略最后一个元素</h3>

<p>这样做的好处有以下几点：</p>

<ul>
<li>当只有最后一个位置时，我们也可以快速看出切片和区间有多少个元素，比如<code>my_list[:5]</code>有5个元素</li>
<li>当起止位置信息都可见的时候，我们可以快速计算出区间的长度，即后一个数减去第一个数</li>
<li>可以让我们使用任意一个数把区间分成两个部分，比如<code>my_list[:x]</code>和<code>my_list[x:]</code></li>
</ul>

<h3 id="toc_5">切片的使用方法</h3>

<p>可以使用<code>my_list[a:b]</code>的形式对序列进行基本的切片操作，也可以用<code>my_list[a:b:c]</code>的形式对列表my_list在a和b之间以c间隔进行取值，c的值也可以是负值，代表反向取值，如下所示：</p>

<pre><code class="language-python">def split_for_object(object_ex):
    print(object_ex)
    print(object_ex[2:5])
    print(object_ex[:4])
    print(object_ex[::3])
    print(object_ex[::-1])
    print(object_ex[::-2])
   
split_for_object(&quot;abcdefghijklmn&quot;)
</code></pre>

<p>程序运行的返回结果如下：</p>

<pre><code class="language-Python">abcdefghijklmn
cde
abcd
adgjm
nmlkjihgfedcba
nljhfdb
</code></pre>

<h2 id="toc_6">序列的+和*</h2>

<p>+可用于两个序列的拼接操作，*用于一个序列重复n次的操作，这两个运算符都不修改原有的序列，而是产生一个新的序列。示例如下所示：</p>

<pre><code class="language-python"># 序列的+运算
def do_add(a, b):
    print(a + b)


# 序列的*运算
def do_mul(a, n):
    print(a * n)

do_add(&quot;hello &quot;, &quot;world!&quot;)
do_mul(&quot;ABB-&quot;, 4)
</code></pre>

<p>*的运用有一个需要注意的地方，即在执行<code>a*n</code>的过程中，如果a中有元素是对其他可变对象的引用，则运算完成之后就得到n个同样的引用，修改一处则会有多处进行修改。比如下面这个示例：</p>

<pre><code class="language-python">def wrong_ex():
    weird_board = [[&#39;_&#39;] * 3] * 3
    print(weird_board)
    weird_board[0][2] = &#39;A&#39;
    print(weird_board)


def right_ex():
    weird_board = [[&#39;_&#39;] * 3 for i in range(3)]
    print(weird_board)
    weird_board[0][2] = &#39;A&#39;
    print(weird_board)

wrong_ex()
right_ex()
</code></pre>

<p>上面示例的运行结果如下：</p>

<pre><code class="language-python">[[&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;]]
[[&#39;_&#39;, &#39;_&#39;, &#39;A&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;A&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;A&#39;]]
[[&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;]]
[[&#39;_&#39;, &#39;_&#39;, &#39;A&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;]]

</code></pre>

<h2 id="toc_7">序列的增量赋值</h2>

<h3 id="toc_8">就地加法</h3>

<p>增量赋值的写法就是类似于<code>a += b</code>的样子，+=背后用到的特殊方法是<code>__iadd__</code>，但是如果一个类没有实现这个方法，python就会退而求其次，使用<code>__add__</code>方法。这两个方法还是有根本的区别的：</p>

<ul>
<li><code>__iadd__</code>方法也称‘就地加法’，因为在做运算的时候，a会就地改动，效果就像<code>a.extend(b)</code>一样，不会出现新的对象。</li>
<li><code>__add__</code>方法在做加法运算的时候，会先计算<code>a + b</code>，然后将结果存到一个新的对象中，再将这个对象赋值给a。</li>
</ul>

<p>需要注意的是，就地加法只能运用在可变序列中，不可变序列不会在原地进行修改。如下示例所示：</p>

<pre><code class="language-python"># 就地加法在可变序列和不可变序列中的应用
def iadd_ex():
    a = [1, 2, 3]
    b = (4, 5, 6)
    c = [7, 8, 9]
    d = (10, 11, 12)
    print(&quot;id for a :{}&quot;.format(id(a)))
    print(&quot;id for b :{}&quot;.format(id(b)))

    a += c
    b += d
    print(&quot;id for a after run a += c : {}&quot;.format(id(a)))
    print(&quot;id for b after run b += c : {}&quot;.format(id(b)))

iadd_ex()
</code></pre>

<p>示例结果如下：</p>

<pre><code class="language-python">id for a :4324181576
id for b :4324140952
id for a after run a += c : 4324181576
id for b after run b += c : 4324209000
</code></pre>

<p>由此可见：对不可变序列进行重复拼接操作的话，效率会变得很低，因为解释其需要把原来对象中的元素拷贝到新的位置，然后在执行拼接操作。</p>

<p><strong>注意，str作为不可变序列，重复操作时没有效率降低的说法，因为对str类型数据做+=操作太普遍，python就对其进行了优化，在申请空间时，程序会预留可扩展空间给str，因此不会涉及到复制的操作，而是直接执行拼接</strong></p>

<h3 id="toc_9">就地乘法</h3>

<p>就地乘法的使用和就地加法很相似，只不过就地乘法用到而特殊方法是：<code>__imul__</code></p>

<h2 id="toc_10">list.sort() and sorted()</h2>

<ul>
<li>list.sort()方法是就地排序，执行完这个方法后，原对象有可能发生了变化，同时，这个方法也不会返回任何值。</li>
<li>sorted()方法做排序操作时，会新建一个列表作为返回值，这个方法可以接受任何形式的可迭代对象作为参数，也可以包括不可变对象和生成器，只是最后返回的都会是一个列表。</li>
</ul>

<p>list.sort()方法和sorted()方法虽然实现不同，但都有两个可选的关键字参数：</p>

<ul>
<li>reverse： 指明最终序列是升序还是降序，这个参数的默认值是False，代表升序。</li>
<li>key： 一个只有一个参数的函数，这个函数会被用在序列里的每一个元素上，函数所产生的结果就是排序算法依赖的对比关键字。默认用元素自己的值来排序。</li>
</ul>

<pre><code class="language-python"># list.sort()方法和sorted()方法的使用
def sort_and_sorted():
    fruits = [&#39;grape&#39;, &#39;watermelon&#39;, &#39;apple&#39;, &#39;banana&#39;]
    # 通过下面两个输出可以证明sorted()方法不改变原来的序列
    print(sorted(fruits))
    print(fruits)

    # 按照元素本身进行降序排序,这里就是字母顺序
    print(sorted(fruits, reverse=True))

    # 按照长度进行升序排序
    print(sorted(fruits, key=len))

    # 按照长度进行降序排序
    print(sorted(fruits, key=len, reverse=True))

    # 通过下面两个打印可以证明list.sort()方法是就地排序
    print(fruits)
    fruits.sort()
    print(fruits)

sort_and_sorted()
</code></pre>

<p>程序的运行结果如下：</p>

<pre><code class="language-python">[&#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;watermelon&#39;]
[&#39;grape&#39;, &#39;watermelon&#39;, &#39;apple&#39;, &#39;banana&#39;]
[&#39;watermelon&#39;, &#39;grape&#39;, &#39;banana&#39;, &#39;apple&#39;]
[&#39;grape&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;watermelon&#39;]
[&#39;watermelon&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;apple&#39;]
[&#39;grape&#39;, &#39;watermelon&#39;, &#39;apple&#39;, &#39;banana&#39;]
[&#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;watermelon&#39;]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python的特殊方法]]></title>
    <link href="http://blog.yanzl.net/15007111565327.html"/>
    <updated>2017-07-22T16:12:36+08:00</updated>
    <id>http://blog.yanzl.net/15007111565327.html</id>
    <content type="html"><![CDATA[
<p>Python提供了各种各样的特殊方法,使用这些方法可以实现自定义的类。</p>

<h2 id="toc_0">特殊方法的基本使用</h2>

<p>特殊方法是给Python解释器调用的，我们不需要使用my_object.__len__()这种方法进行调用，而是写作len(my_object)的形式。</p>

<p>很多时候，特殊方法的调用是隐式的，比如我们使用for对某个对象进行迭代的时候，会优先调用iter()方法，而iter()方法的背后是<code>__iter__</code>方法。</p>

<h3 id="toc_1">利用特殊方法可以做哪些事情</h3>

<p>不同的特殊方法可以实现不同的功能，下面列举一些简单的示例</p>

<h4 id="toc_2">模拟数值类型</h4>

<p>如果我们想实现向量的各种运算，可以创建一个向量类，利用特殊方法进行实现，如下代码所示：</p>

<pre><code>from math import hypot

class Vector:
    def __init__(self, x = 0, y = 0):
        self.x = x
        self.y = y

    def __add__(self, other):
        x = self.x + other.x
        y = self.y + other.y
        return Vector(x, y)

    def __mul__(self, other):
        return Vector(self.x * other, self.y * other)

    def __abs__(self):
        # hypot 用来返回向量的模
        return hypot(self.x, self.y)

    def __bool__(self):
        return bool(abs(self)) 
        
    def __repr__(self):
        return &quot;Vector ({}, {})&quot;.format(self.x, self.y)  
</code></pre>

<h4 id="toc_3">字符串表示形式</h4>

<p>有时候，我们在控制台打印某个对象的时候，我们得到的会是类似于<code>&lt;Vector object at ...&gt;</code>的形式，因为该对象没有实现__repr__的方法。<br/>
<code>__repr__</code>方法的作用是把一个对象用字符串的方式表示出来，当使用交互式控制台或者调试程序的时候会调用这个方法。<br/>
<code>__str__</code>方法也会实现类似的功能，与<code>__repr__</code>方法不同的是该方法会被str()函数 ，或者使用print时调用，并且一个对象如果没有实现<code>__str__</code>方法，则会使用<code>__repr__</code>方法代替，反之则行不通。</p>

<h4 id="toc_4">算术运算符</h4>

<p>可以使用<code>__add__</code>，<code>__mul__</code>等方法实现运算符的操作，例如Vector的示例</p>

<h4 id="toc_5">自定义布尔值</h4>

<p>python自定义的bool类型还是有一定的局限性，比如我们自己定义的类总会被认为真，如果我们对类的bool判断有新的规则，则可以使用<code>__bool__</code>方法进行实现，例如Vector的示例。</p>

<p><strong>注意 如果我们自定义的类中实现了__len__方法，使用python自带的bool进行判断时，该方法会调用__len__方法，如果__len__的返回值为0，则为假，其他的值返回真</strong> </p>

<h3 id="toc_6">python 特殊方法一览</h3>

<p><img src="http://cdn.blog.yanzl.net/2017-07-22-095117.jpg" alt=""/></p>

<p><img src="http://cdn.blog.yanzl.net/2017-07-22-magic_method2.png" alt=""/></p>

<p><img src="http://cdn.blog.yanzl.net/2017-07-22-magic_method3.png" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL数据库☞数据库编码]]></title>
    <link href="http://blog.yanzl.net/14830907697555.html"/>
    <updated>2016-12-30T17:39:29+08:00</updated>
    <id>http://blog.yanzl.net/14830907697555.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">概述</h2>

<p>MySQL是平时常用的数据库之一，在存储中文的时候，经常出现乱码的情况，今天总结一下关于乱码出现的原因以及解决方法。</p>

<h2 id="toc_1">数据的存入取出</h2>

<p>我们知道，MySQL的逻辑架构包括三层，最上表面一层是客户端，我们也是通过各类客户端来操作MySQL；中间一层是MySQL的核心所在，一般包括了查询解析、分析、优化、缓存、所有的内置函数、所有的跨存储引擎的功能（存储过程、触发器、视图等）都在这一层实现；最下面一层就是MySQL的存储引擎，包括我们熟悉的（InnoDB，MyIsAM等MySQL的内建存储引擎和第三方存储引擎）</p>

<p>将数据存入MySQL的时候，</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL数据库☞中文乱码问题]]></title>
    <link href="http://blog.yanzl.net/14830842110487.html"/>
    <updated>2016-12-30T15:50:11+08:00</updated>
    <id>http://blog.yanzl.net/14830842110487.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">背景</h2>

<pre><code>show variables like &#39;character_set_%&#39;;
</code></pre>

<p>结果为：</p>

<table>
<thead>
<tr>
<th>Variable_name</th>
<th>Value</th>
</tr>
</thead>

<tbody>
<tr>
<td>character_set_client</td>
<td>utf8</td>
</tr>
<tr>
<td>character_set_connection</td>
<td>utf8</td>
</tr>
<tr>
<td>character_set_database</td>
<td>utf8</td>
</tr>
<tr>
<td>character_set_filesystem</td>
<td>binary</td>
</tr>
<tr>
<td>character_set_results</td>
<td>utf8</td>
</tr>
<tr>
<td>character_set_server</td>
<td>utf8</td>
</tr>
<tr>
<td>character_set_system</td>
<td>utf8</td>
</tr>
<tr>
<td>character_sets_dir</td>
<td>/usr/local/Cellar/mysql/5.7.13/share/mysql/charsets/</td>
</tr>
</tbody>
</table>

<p><strong>测试数据库的编码为：</strong> utf8</p>

<p><strong>创建数据表</strong></p>

<pre><code class="language-mysql">CREATE TABLE `one` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=226 DEFAULT CHARSET=utf8 |
</code></pre>

<p>在该状态下写入一条语句：</p>

<pre><code class="language-mysql">insert into one (name) values(&quot;测试姓名&quot;);
</code></pre>

<p>&quot;测试名字&quot;数据是在所有的字符集都是utf8的情况下插入的<br/>
&quot;测试名字123&quot;数据是在表的字符集属于latin1的情况下插入的<br/>
“测试名字abc”数据是在表和连接的字符集是latin1的情况下插入的<br/>
&quot;测试名字456&quot;数据是在连接的字符集是latin1的情况下插入的，</p>

<h2 id="toc_1">开始测试</h2>

<h3 id="toc_2">测试单一非正常字符集对中文的影响</h3>

<p>分别执行以下操作：</p>

<pre><code>alter table one default character set latin1;
set character_set_connection=latin1;
alter database test default character set latin1;
set character_set_client=latin1;
</code></pre>

<p>然后分别查询表中的中文数据，发现能够正常显示中文数据&quot;测试名字&quot;，可见中文乱码与其中一个非正常字符集是没有关系的。</p>

<h3 id="toc_3">测试组合非正常字符集对中文的影响</h3>

<p>一起执行如下语句：</p>

<pre><code>alter table one default character set latin1;
set character_set_connection=latin1;
alter database test default character set latin1;
set character_set_client=latin1;
</code></pre>

<p>查询表中中文数据，发现能够正常显示数据“测试名字”,&quot;测试名字123&quot;</p>

<pre><code>set character_set_connection=latin1;
alter table one default character set latin1;
</code></pre>

<p>查询表中中文数据，发现“测试名字”，“测试名字123”显示正常， “测试名字abc”乱码</p>

<pre><code>set character_set_connection=latin1;
</code></pre>

<p>查询表中数据，发现&quot;测试名字&quot;， “测试名字123”显示正常， “测试名字abc”乱码</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL的基本命令☞数据表的基本管理]]></title>
    <link href="http://blog.yanzl.net/14819928857822.html"/>
    <updated>2016-12-18T00:41:25+08:00</updated>
    <id>http://blog.yanzl.net/14819928857822.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">创建数据表</h2>

<pre><code>CREATE TABLE `table_name` (
  `name` varchar(30) NOT NULL DEFAULT &#39;&#39;,
  `age` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `first_name` varchar(64) DEFAULT NULL,
  `last_name` varchar(64) DEFAULT NULL,
  `email` varchar(128) DEFAULT NULL,
  `phone` varchar(32) DEFAULT NULL,
  `city` varchar(128) DEFAULT NULL,
  `country` varchar(128) DEFAULT NULL,
  `notes` text,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=226 DEFAULT CHARSET=utf8;
</code></pre>

<h2 id="toc_1">添加一个主键字段</h2>

<p>添加主键其实是两个操作，一个是添加一个字段，另一个操作是设置该字段为主键</p>

<pre><code>alter table table_name add id int not null auto_increment,
add primary key (id);
</code></pre>

<h2 id="toc_2">为一个字段添加主键</h2>

<pre><code>alter table table_name add primary key (age);
</code></pre>

<h2 id="toc_3">添加一个普通字段</h2>

<pre><code>alter table table_name add user_id int not null;
</code></pre>

<h2 id="toc_4">删除一个字段</h2>

<pre><code>alter table user drop column phone;
</code></pre>

<h2 id="toc_5">修改一个字段</h2>

<p>只修改一个字段的类型：</p>

<pre><code>alter table user modify city varchar(100);
</code></pre>

<p>修改字段的全部定义,该方法也用于重命名：</p>

<pre><code>alter table user change city user_city varchar(128) not null default &#39;&#39;;
</code></pre>

<h2 id="toc_6">添加外键</h2>

<p><strong>注意这里设置的外键字段（user_id）必须在表中存在</strong></p>

<pre><code>alter table table_name add CONSTRAINT `table_name_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `user`(`id`);
</code></pre>

<h2 id="toc_7">删除外键</h2>

<p>删除外键用到的外键名是添加外键时指定的外键符号，即constraint 后面的单词，如果建表时没有指定外键符号，MySQL会自动创建，只需要通过<code>show create table table_name;</code> 进行查看就可以了。</p>

<pre><code>alter table table_name drop foreign key table_name_ibfk_1;
</code></pre>

<p><strong>这里顺便写一下修改外键的方法：先删除原来的外键，再添加新的外键</strong></p>

<h2 id="toc_8">添加唯一索引</h2>

<pre><code>alter table table_name add unique (name);
create unique index unique_index_name on table_name (name);
</code></pre>

<h2 id="toc_9">添加普通索引</h2>

<pre><code>alter table table_name add index name_index (name);
create index name_index on table_name (name);
</code></pre>

<h2 id="toc_10">添加全文索引</h2>

<pre><code>ALTER TABLE `table_name` ADD FULLTEXT ( `name`);
</code></pre>

<h2 id="toc_11">添加联合索引</h2>

<p><strong>注意联合索引是有顺序的</strong></p>

<pre><code>ALTER TABLE `table_name` ADD INDEX union_index_name (`id`, `name`);
</code></pre>

<h2 id="toc_12">删除索引</h2>

<p>除了删除主键索引需要用到<code>alter table table_name primary key</code>语句之外，删除其它索引都可以使用如下两种方法：</p>

<pre><code>drop index union_index_name on table_name;
alter table table_name drop index union_index_name;
alter table table_name drop index name_index;
alter table table_name drop index name;
alter table table_name drop index name_2;
</code></pre>

<h2 id="toc_13">查看所有索引</h2>

<pre><code>show index from table_name;
show keys from table_name;
</code></pre>

<ul>
<li>Table :表的名称。</li>
<li>Non_unique :如果索引不能包括重复词，则为0。如果可以，则为1。</li>
<li>Key_name :索引的名称。</li>
<li>Seq_in_index :索引中的列序列号，从1开始。</li>
<li>Column_name :列名称。</li>
<li>Collation :列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。</li>
<li>Cardinality :索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。</li>
<li>Sub_part :如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。</li>
<li>Packed :指示关键字如何被压缩。如果没有被压缩，则为NULL。</li>
<li>Null :如果列含有NULL，则含有YES。如果没有，则该列含有NO。</li>
<li>Index_type :用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。</li>
<li>Comment</li>
</ul>

<h2 id="toc_14">修改表名</h2>

<pre><code>ALTER  TABLE table_name RENAME TO test_table;
</code></pre>

<h2 id="toc_15">删除表</h2>

<pre><code>drop table table_name
</code></pre>

<h2 id="toc_16">创建包含各种索引类型的表</h2>

<pre><code>CREATE TABLE `test_table` (
  `name` varchar(30) NOT NULL DEFAULT &#39;&#39;,
  `age` int(11) NOT NULL,
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_index_name` (`name`),
  KEY `table_name_ibfk_1` (`user_id`),
  KEY `name_index` (`name`),
  KEY `union_index_name` (`id`,`name`),
  FULLTEXT KEY `name` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python容器数据类型☞collections]]></title>
    <link href="http://blog.yanzl.net/14745361920074.html"/>
    <updated>2016-09-22T17:23:12+08:00</updated>
    <id>http://blog.yanzl.net/14745361920074.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">namedtuple(命名元组)</h2>

<p>元组tuple是python内置的数据类型，其特点是一次写入不可修改，元组内每个元素的数据类型都是可以不一样的。但有时候，我们需要给每个元素起一个名字，以便更好地区分每个元素的身份。命名元组namedtuple就可以完美的实现这个功能,它用来创建一个自定义的元组对象，规定元组对象的个数，可以用属性名来读取对象元素的值。<br/>
命名元组会返回一个元组的基类，数据类型已经变成class，而不再是tuple</p>

<h3 id="toc_1">函数原型</h3>

<pre><code class="language-python">collections.namedtuple(typename, field_names, verbose=False, rename=False)
</code></pre>

<ul>
<li>field_names:命名元组中各属性的名称，可以是字母，数字，下划线表示，但只能以字母开头。定义方法有多种形式，可以是一个字符串，以空格或者逗号分割，也可以是一个列表。有几个需要注意的地方：

<ul>
<li>属性名不能够重复</li>
<li>属性名不能够使用python关键字</li>
</ul></li>
<li>verbose：布尔值类型数据，默认为False，如果为True。则会在命名元组创建之后打印类的定义，但是这种访问类定义的方法已经很少会被用到了，更多的是使用_source属性，后面会讲。</li>
<li>rename：布尔值类型数据，默认为False，如果为True，则会将field_names中不合法的命名进行自动替换，在False的情况下，遇到不合法的命名程序会报错。</li>
</ul>

<h3 id="toc_2">类属性</h3>

<p>上面已经说过，namedtuple会返回一个元组基类，这里介绍几个类属性：</p>

<ul>
<li>namedtuplename._make(iterable): 把一个变量内容赋值给namedtuple</li>
<li>namedtuplename.asdict(): 把命名元组转换成字典类型</li>
<li>namedtuplename._source: 打印命名元组的定义语句</li>
<li>namedtuplename._replace(kwargs）：为命名元组的元素重置值</li>
<li>namedtuplename._fields:返回namedtuple的所有属性名</li>
</ul>

<h3 id="toc_3">示例代码</h3>

<pre><code class="language-python"># 引入模块
from collections import namedtuple
# namedtuple的定义和基本使用
Users = namedtuple(&quot;Users&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;weight&quot;, &quot;height&quot;, &quot;hobby&quot;], False)
user_info = Users(&quot;zhangsan&quot;, 12, 82, 156, &quot;basketball&quot;)
print(user_info)
print(type(user_info))

# rename的开启和关闭和打印namedtuple的属性名
Users = namedtuple(&quot;Users&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;def&quot;, &quot;height&quot;, &quot;age&quot;], False, True)
Users1 = namedtuple(&quot;Users&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;weight&quot;, &quot;height&quot;, &quot;hobby&quot;], False)
Users2 = namedtuple(&quot;Users&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;def&quot;, &quot;2dhfv&quot;, &quot;age&quot;], False, True)
print(Users._fields)
print(Users1._fields)
print(Users2._fields)

# 整体给namedtuple赋值
Users = namedtuple(&quot;Users&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;weight&quot;, &quot;height&quot;, &quot;hobby&quot;], False)
user_info = (&quot;zhangsan&quot;, 12, 82, 155, &quot;football&quot;) # 可以是列表,也可以是元组
print(Users._make(user_info))

# 命名元组转换成字典类型
Users = namedtuple(&quot;Users&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;weight&quot;, &quot;height&quot;, &quot;hobby&quot;], False)
user_info = Users(&quot;zhangsan&quot;, 12, 82, 156, &quot;basketball&quot;)
print(type(user_info))
print(type(user_info._asdict()))

# 查看namedtuple的定义语句
Users = namedtuple(&quot;Users&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;weight&quot;, &quot;height&quot;, &quot;hobby&quot;], False)
print(Users._source)

# 更改namedtuple的元素值
Users = namedtuple(&quot;Users&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;weight&quot;, &quot;height&quot;, &quot;hobby&quot;], False)
user_info = Users(&quot;zhangsan&quot;, 12, 82, 156, &quot;basketball&quot;)
print(user_info)
user_info2 = user_info ._replace(hobby=&quot;football&quot;)
print(user_info)
print(user_info2)
</code></pre>

<h3 id="toc_4">参考结果</h3>

<pre><code class="language-python"># 命名元组的基本赋值应用
Users(name=&#39;zhangsan&#39;, age=12, weight=82, height=156, hobby=&#39;basketball&#39;)
&lt;class &#39;__main__.Users&#39;&gt;
# 开启rename模式与不开启的对比,开启之后会将不合法的命名自动改为合法的命名，使用_fields类方法可以查看属性名
(&#39;name&#39;, &#39;age&#39;, &#39;_2&#39;, &#39;height&#39;, &#39;_4&#39;)
(&#39;name&#39;, &#39;age&#39;, &#39;weight&#39;, &#39;height&#39;, &#39;hobby&#39;)
(&#39;name&#39;, &#39;age&#39;, &#39;_2&#39;, &#39;_3&#39;, &#39;_4&#39;)
# 使用_make()方法整体给namedtuple赋值，可以看出和分开赋值并没有什么区别
Users(name=&#39;zhangsan&#39;, age=12, weight=82, height=155, hobby=&#39;football&#39;)
# 使用_asdict()方法将命名元组转换成字典类型
&lt;class &#39;__main__.Users&#39;&gt;
&lt;class &#39;collections.OrderedDict&#39;&gt;
# 查看namedtuple的定义语句运行结果比较长，可以自行运行查看结果
# 使用_replace()方法对属性值进行更改，该方法会返回一个新的对象，而不是从原来的对象上面进行修改
Users(name=&#39;zhangsan&#39;, age=12, weight=82, height=156, hobby=&#39;basketball&#39;)
Users(name=&#39;zhangsan&#39;, age=12, weight=82, height=156, hobby=&#39;basketball&#39;)
Users(name=&#39;zhangsan&#39;, age=12, weight=82, height=156, hobby=&#39;football&#39;)
</code></pre>

<h2 id="toc_5">deque（双端队列）</h2>

<p>deque的全称是double-ended queue，可以实现从队列的头部快速添加和取出元素，这是一个双向列表，可以从右端操作元素，也可以从左端操作元素，且时间复杂度都为O(1)</p>

<h3 id="toc_6">函数原型</h3>

<p>class collections.deque([iterable[, maxlen]]）</p>

<ul>
<li>interable： 可选参数，在队列创建的时候根据数值从左往右初始化队列,如果是多个元素，必须用括号括起来，否则会报错。没有该参数时会初始化一个空的队列</li>
<li>maxlen：指定队列的最大长度,如果超出长度，则会自动丢掉左边超出的部分，如果采用左添加时元素长度超出，会舍掉右端的元素</li>
</ul>

<p>示例代码</p>

<pre><code class="language-python">from collections import deque
data = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, 123, &quot;yes&quot;]
d = deque(data)
d1 = deque(data, 2)
print(&quot;正常初始化队列:{}&quot;.format(d))
print(&quot;超出长度限制的初始化队列:{}&quot;.format(d1))

d.append(&quot;abc&quot;)
print(&quot;执行正常添加操作:{}&quot;.format(d))
d1.append(&quot;no&quot;)
print(&quot;超出长度限制的右添加操作:{}&quot;.format(d1))
d1.appendleft(&quot;ok&quot;)
print(&quot;超出长度限制的左添加操作:{}&quot;.format(d1))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">正常初始化队列:deque([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, 123, &#39;yes&#39;])
超出长度限制的初始化队列:deque([123, &#39;yes&#39;], maxlen=2)
执行正常添加操作:deque([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, 123, &#39;yes&#39;, &#39;abc&#39;])
超出长度限制的右添加操作:deque([&#39;yes&#39;, &#39;no&#39;], maxlen=2)
超出长度限制的左添加操作:deque([&#39;ok&#39;, &#39;yes&#39;], maxlen=2)
</code></pre>

<h3 id="toc_7">常用方法</h3>

<h4 id="toc_8">添加元素</h4>

<ul>
<li>添加一个值的情况：分为左添加（appendleft()）和右添加（append()）,操作是对原对象进行操作，并且不会返回任何值</li>
<li>添加多个制的情况：分为左添加（extendleft()）和右添加(extend()),注意左添加多个元素时，是按照顺序依次向队列左端进行添加，所以先加入的数据会在右边</li>
</ul>

<p>示例代码</p>

<pre><code class="language-pyton">from collections import deque
data = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, 123, &quot;yes&quot;]
d = deque(data)
d.append(&quot;right&quot;)
print(&quot;执行右添加之后的结果:{}&quot;.format(d))
d.appendleft(&quot;left&quot;)
print(&quot;执行左添加之后的结果:{}&quot;.format(d))
d.extendleft((&quot;left1&quot;, &quot;left2&quot;))
print(&quot;向左边添加多个元素:{}&quot;.format(d))
d.extend((&quot;right1&quot;, &quot;right2&quot;))
print(&quot;向右边添加多个元素:{}&quot;.format(d))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">执行右添加之后的结果:deque([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, 123, &#39;yes&#39;, &#39;right&#39;])
执行左添加之后的结果:deque([&#39;left&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, 123, &#39;yes&#39;, &#39;right&#39;])
向左边添加多个元素:deque([&#39;left2&#39;, &#39;left1&#39;, &#39;left&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, 123, &#39;yes&#39;, &#39;right&#39;])
向右边添加多个元素:deque([&#39;left2&#39;, &#39;left1&#39;, &#39;left&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, 123, &#39;yes&#39;, &#39;right&#39;, &#39;right1&#39;, &#39;right2&#39;])
</code></pre>

<h4 id="toc_9">清空队列</h4>

<p>clear()方法可以将队列进行清空</p>

<p>示例代码</p>

<pre><code class="language-python">from collections import deque
data = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, 123, &quot;yes&quot;]
d = deque(data)
print(&quot;初始化之后的队列:{}&quot;.format(d))
d.clear()
print(&quot;清空之后的队列:{}&quot;.format(d))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">初始化之后的队列:deque([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, 123, &#39;yes&#39;])
清空之后的队列:deque([])
</code></pre>

<h4 id="toc_10">拷贝队列</h4>

<p>copy（）方法可用于拷贝队列，返回一个新的队列，可将这个新的队列赋值给一个变量，两个队列虽然值相同，但存储位置是不一样的。<br/>
示例代码</p>

<pre><code class="language-python">from collections import deque
data = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, 123, &quot;yes&quot;]
d = deque(data)
print(&quot;拷贝之前的队列:{}, 存储位置为:{}&quot;.format(d, id(d)))
d_c = d.copy()
print(&quot;拷贝之后的队列:{},存储位置为:{}&quot;.format(d_c, id(d_c)))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">拷贝之前的队列:deque([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, 123, &#39;yes&#39;]), 存储位置为:4315002048
拷贝之后的队列:deque([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, 123, &#39;yes&#39;]),存储位置为:4315002152
</code></pre>

<h4 id="toc_11">计算某元素出现的次数</h4>

<p>count(x)方法可用来计算队列中x元素一共出现了多少次<br/>
示例代码</p>

<pre><code class="language-python">from collections import deque
data = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, 123, &quot;yes&quot;, &quot;yes&quot;]
d = deque(data, maxlen=6)
print(&quot;队列中的元素出现的次数为:{}&quot;.format(d.count(&quot;yes&quot;)))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">队列中的元素个数为:2
</code></pre>

<h4 id="toc_12">查看某个元素的索引</h4>

<p>index（）方法可用于查找某个元素的索引位置，从0开始索引。如果队列中有多个相同元素，则返回第一个的位置。也可以用于查找某个元素在某一段位置区间下的索引位置，如果找不到会抛出元素不在队列的错误</p>

<p>示例代码</p>

<pre><code class="language-python">from collections import deque
data = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, 123, &quot;yes&quot;, &quot;yes&quot;]
d = deque(data)
print(&quot;查找整个队列中某元素的索引位置:{}&quot;.format(d.index(&quot;yes&quot;)))
print(&quot;查找第一个位置到第三个位置中某元素的索引位置:{}&quot;.format(d.index(&quot;yes&quot;, 1, 3)))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">Traceback (most recent call last):
  File &quot;/Users/yanzilu/Project/Test/collection_test.py&quot;, line 91, in &lt;module&gt;
    print(&quot;查找第一个位置到第三个位置中某元素的索引位置:{}&quot;.format(d.index(&quot;yes&quot;, 1, 3)))
ValueError: &#39;yes&#39; is not in deque
查找整个队列中某元素的索引位置:4
</code></pre>

<h4 id="toc_13">向某位置插入元素</h4>

<p>insert()方法可以实现向队列中某个索引位置插入某个元素，且只能插入一个元素,插入多个元素会报错</p>

<p>示例代码</p>

<pre><code class="language-python">from collections import deque
data = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, 123, &quot;yes&quot;, &quot;yes&quot;]
d = deque(data)

d.insert(3, &quot;add&quot;)
print(&quot;向索引为3的位置插入元素:{}&quot;.format(d))
d.insert(4, [&quot;four&quot;, &quot;five&quot;])
print(&quot;向索引为4的位置插入多个元素:{}&quot;.format(d))
d.insert(4, &quot;four&quot;, &quot;five&quot;)
print(&quot;向索引为4的位置插入多个元素:{}&quot;.format(d))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">向索引为3的位置插入元素:deque([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;add&#39;, 123, &#39;yes&#39;, &#39;yes&#39;])
向索引为4的位置插入多个元素:deque([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;add&#39;, [&#39;four&#39;, &#39;five&#39;], 123, &#39;yes&#39;, &#39;yes&#39;])
Traceback (most recent call last):
  File &quot;/Users/yanzilu/Project/Test/collection_test.py&quot;, line 100, in &lt;module&gt;
    d.insert(4, &quot;four&quot;, &quot;five&quot;)
TypeError: insert() takes exactly 2 arguments (3 given)
</code></pre>

<h4 id="toc_14">取出和移除元素</h4>

<ul>
<li>取出元素分为从左边取出元素（popleft()）和从右边取出元素（pop()）,函数会将取出的值返回出来并在队列中删除</li>
<li>移除元素可以使用remove(value)方法，该方法指定要移除的元素值，并且直接移除元素，不会进行返回，如果该元素不存在，则会报元素不在队列中的错误</li>
</ul>

<p>示例代码</p>

<pre><code class="language-python">from collections import deque
data = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, 123, &quot;yes&quot;, &quot;yes&quot;]
d = deque(data)

print(&quot;操作之前的数据:{}&quot;.format(d))
print(&quot;执行从队列右侧取出元素的返回值:{},队列变成:{}&quot;.format(d.pop(), d))
print(&quot;执行从队列左侧取出元素返回值:{}, 队列变成:{}&quot;.format(d.popleft(), d))
print(&quot;移除值为three的元素:{}, 队列变成:{}&quot;.format(d.remove(&quot;three&quot;), d))
print(&quot;移除一个不存在的值:{}&quot;.format(d.remove(&quot;four&quot;)))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">操作之前的数据:deque([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, 123, &#39;yes&#39;, &#39;yes&#39;])
执行从队列右侧取出元素的返回值:yes,队列变成:deque([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, 123, &#39;yes&#39;])
执行从队列左侧取出元素返回值:one, 队列变成:deque([&#39;two&#39;, &#39;three&#39;, 123, &#39;yes&#39;])
移除值为three的元素:None, 队列变成:deque([&#39;two&#39;, 123, &#39;yes&#39;])
Traceback (most recent call last):
  File &quot;/Users/yanzilu/Project/Test/collection_test.py&quot;, line 111, in &lt;module&gt;
    print(&quot;移除一个不存在的值:{}&quot;.format(d.remove(&quot;four&quot;)))
ValueError: deque.remove(x): x not in deque
</code></pre>

<h4 id="toc_15">反转队列和旋转队列</h4>

<ul>
<li>反转：reverse()方法可以实现队列的反转</li>
<li>旋转: rotate(n)方法可以向右旋转n个元素，如果n是负值，则为向左旋转n个元素</li>
</ul>

<p>示例代码</p>

<pre><code class="language-python">from collections import deque
data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
d = deque(data)

print(&quot;反转之前的队列:{}&quot;.format(d))
d.reverse()
print(&quot;反转之后的队列:{}&quot;.format(d))
d.rotate(4)
print(&quot;旋转队列4个元素:{}&quot;.format(d))
d.rotate(-2)
print(&quot;旋转队列-4个元素:{}&quot;.format(d))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">反转之前的队列:deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
反转之后的队列:deque([11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1])
旋转队列4个元素:deque([4, 3, 2, 1, 11, 10, 9, 8, 7, 6, 5])
旋转队列-4个元素:deque([2, 1, 11, 10, 9, 8, 7, 6, 5, 4, 3])
</code></pre>

<h2 id="toc_16">Counter(计数器)</h2>

<p>用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value。计数值可以是任意的Interger（包括0和负数）。</p>

<h3 id="toc_17">类的创建</h3>

<p>Counter类有四种常用的创建方法：</p>

<pre><code class="language-python">from collections import Counter

c = Counter()
print(&quot;这是一个空的Counter类:{}&quot;.format(c))
c = Counter(&#39;iterable object&#39;)
print(&quot;从一个可迭代的对象(list、tuple、dict、字符串等)创建Counter类:{}&quot;.format(c))
c = Counter({&quot;one&quot;: 1, &quot;two&quot;: 2})
print(&quot;从一个字典对象创建Counter类:{}&quot;.format(c))
c = Counter(one=1, two=2)
print(&quot;从一组键值对创建:{}&quot;.format(c))
</code></pre>

<p>创建结果如下：</p>

<pre><code class="language-python">这是一个空的Counter类:Counter()
从一个可迭代的对象(list、tuple、dict、字符串等)创建Counter类:Counter({&#39;e&#39;: 3, &#39;t&#39;: 2, &#39;b&#39;: 2, &#39;c&#39;: 1, &#39;r&#39;: 1, &#39;j&#39;: 1, &#39;o&#39;: 1, &#39;l&#39;: 1, &#39; &#39;: 1, &#39;a&#39;: 1, &#39;i&#39;: 1})
从一个字典对象创建Counter类:Counter({&#39;two&#39;: 2, &#39;one&#39;: 1})
从一组键值对创建:Counter({&#39;two&#39;: 2, &#39;one&#39;: 1})
</code></pre>

<h3 id="toc_18">计数器的更新和值的访问</h3>

<ul>
<li>访问分为两种情况，一种是访问的键存在，返回该键所对应的值；另一种是键不存在的情况，返回的是0</li>
<li>使用update方法增加计数器，有两种方法，一种是通过可迭代对象，另一种是通过另一个Counter对象</li>
<li>使用subtract()方法减少计数器，有两种方法，一种是通过可迭代对象，另一种是通过另一个Counter对象</li>
</ul>

<p>示例代码</p>

<pre><code class="language-python">from collections import Counter

c = Counter(one=1, two=2)
print(&quot;访问一个存在的键:{}&quot;.format(c[&quot;one&quot;]))
# 即使访问不存在的键，键名也不会添加进计数器中
print(&quot;访问一个不存在的键:{},访问过后计数器变成:{}&quot;.format(c[&quot;three&quot;], c))
# 注意这里如果不加中括号，则添加的就不是&quot;one&quot;和“two”的次数，而是每个字符
c.update([&quot;one&quot;, &quot;two&quot;])
print(&quot;通过另一个迭代器进行更新:{}&quot;.format(c))
c1 = Counter({&quot;one&quot;: 10, &quot;two&quot;: 20})
c.update(c1)
print(&quot;通过另一个Counter对象进行计数器的增加:{}&quot;.format(c))
# 减少计数器的使用和增加很像,需要注意的是减少到0时不会将键删除，而是继续减少，即次数可以是赋值
c1 = Counter({&quot;one&quot;: 30, &quot;two&quot;: 40})
c.subtract(c1)
print(&quot;通过另一个Counter对象进行计数器的减少:{}&quot;.format(c))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">访问一个存在的键:1
访问一个不存在的键:0,访问过后计数器变成:Counter({&#39;two&#39;: 2, &#39;one&#39;: 1})
通过另一个迭代器进行更新:Counter({&#39;two&#39;: 3, &#39;one&#39;: 2})
通过另一个Counter对象进行计数器的增加:Counter({&#39;two&#39;: 23, &#39;one&#39;: 12})
通过另一个Counter对象进行计数器的减少:Counter({&#39;two&#39;: -17, &#39;one&#39;: -18})
</code></pre>

<h3 id="toc_19">键的删除</h3>

<p>使用del对键进行删除，可以使用update()方法在更新时把没有的键添加进去</p>

<p>示例代码</p>

<pre><code class="language-python">from collections import Counter

c = Counter(one=1, two=2)
del c[&quot;one&quot;]
print(&quot;删除one键之后的计数器变成:{}&quot;.format(c))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">删除one键之后的计数器变成:Counter({&#39;two&#39;: 2})
</code></pre>

<h3 id="toc_20">elements()方法</h3>

<p>该方法返回一个迭代器。元素被重复了多少次，在该迭代器中就包含多少个该元素。所有元素按照字母序排序，个数小于1的元素不被包含。</p>

<p>示例代码</p>

<pre><code class="language-python">from collections import Counter
c = Counter(one=5, two=3)
print(&quot;迭代之后的元素:{}&quot;.format(list(c.elements())))
print(&quot;迭代之后的元素:{}&quot;.format(set(c.elements())))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">迭代之后的元素:[&#39;two&#39;, &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;one&#39;, &#39;one&#39;, &#39;one&#39;, &#39;one&#39;]
迭代之后的元素:{&#39;two&#39;, &#39;one&#39;}
</code></pre>

<h3 id="toc_21">most_common([n])方法</h3>

<p>该方法返回一个含前n个元素计数的列表。如果n没有被指定，则返回所有元素。当多个元素计数值相同时，按照字母序排列。</p>

<p>示例代码</p>

<pre><code class="language-python">from collections import Counter
c = Counter(one=5, two=3, three=12)
print(&quot;返回所有元素的计数:{}&quot;.format(c.most_common()))
print(&quot;返回前2个元素的计数:{}&quot;.format(c.most_common(2)))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">返回所有元素的计数:[(&#39;three&#39;, 12), (&#39;one&#39;, 5), (&#39;two&#39;, 3)]
返回前2个元素的计数:[(&#39;three&#39;, 12), (&#39;one&#39;, 5)]
</code></pre>

<h2 id="toc_22">OrderedDict（排序字典）</h2>

<p>在Python中，dict这个数据结构由于hash的特性，是无序的，有时候我们会用到键的顺序，collections模块为我们提供了OrderedDict，当要获得一个有序的字典对象时，就可以使用OrderedDict。<br/>
OrderedDict的数据都是以每个键值对作为一个元组组成的列表。</p>

<h3 id="toc_23">类的原型</h3>

<pre><code class="language-python">class collections.OrderedDict([items])
</code></pre>

<h3 id="toc_24">初始化</h3>

<p>有序字典的顺序是元素添加的顺序.初始化的时候如果有多个元素，注意初始值之间的顺序，列表，元组等有序数据结构都是可以的，但是字典是无序的，在初始的时候顺序有可能不会是写的顺序。</p>

<p>示例代码</p>

<pre><code class="language-python">from collections import OrderedDict

od = OrderedDict([(&quot;one&quot;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)])
print(od)
di = {&quot;one&quot;:1, &quot;two&quot;: 2, &quot;three&quot;: 3}
print(&quot;对比普通字典: {}&quot;.format(di))
od[&quot;four&quot;] = 4
print(&quot;添加一个元素之后的字典:{}&quot;.format(od))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">OrderedDict([(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)])
对比普通字典: {&#39;two&#39;: 2, &#39;one&#39;: 1, &#39;three&#39;: 3}
添加一个元素之后的字典:OrderedDict([(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3), (&#39;four&#39;, 4)])
</code></pre>

<h3 id="toc_25">popitem(last=True)方法</h3>

<p>该方法用来移除字典中的元素，如果last值为真，则采取先进后出的原则，移除最后的元素，last值为假时，采取先进先出的原则，移除最开始的元素</p>

<p>示例代码</p>

<pre><code class="language-python">from collections import OrderedDict

od = OrderedDict([(&quot;one&quot;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3), (&quot;four&quot;, 4)])
print(&quot;移除元素之前的字典:{}&quot;.format(od))
od.popitem()
print(&quot;先进后出移除元素之后的字典:{}&quot;.format(od))
od.popitem(False)
print(&quot;先进先出移除元素之后的字典:{}&quot;.format(od))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">移除元素之前的字典:OrderedDict([(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3), (&#39;four&#39;, 4)])
先进后出移除元素之后的字典:OrderedDict([(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)])
先进先出移除元素之后的字典:OrderedDict([(&#39;two&#39;, 2), (&#39;three&#39;, 3)])
</code></pre>

<h3 id="toc_26">move_to_end(key, last=True)方法</h3>

<p>将字典中的某个元素移动到最后的位置，需要注意的是最后的位置是根据last值决定的，值为True时，为先进后出（栈）模式，则最后进来的那一端为后端，值为False时，为先进先出（队列）模式,最先进来的一端为后端。<br/>
总之，后端的确定是popitem()时，从哪一边开始移除元素，哪一边就是后端</p>

<p>示例代码</p>

<pre><code class="language-python">from collections import OrderedDict

od = OrderedDict([(&quot;one&quot;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3), (&quot;four&quot;, 4)])
print(&quot;移动元素之前的字典:{}&quot;.format(od))
od.move_to_end(&quot;one&quot;)
print(&quot;先进后出移动元素之后的字典:{}&quot;.format(od))
od.move_to_end(&quot;three&quot;, last=False)
print(&quot;先进先出移动元素之后的字典:{}&quot;.format(od))
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">移动元素之前的字典:OrderedDict([(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3), (&#39;four&#39;, 4)])
先进后出移动元素之后的字典:OrderedDict([(&#39;two&#39;, 2), (&#39;three&#39;, 3), (&#39;four&#39;, 4), (&#39;one&#39;, 1)])
先进先出移动元素之后的字典:OrderedDict([(&#39;three&#39;, 3), (&#39;two&#39;, 2), (&#39;four&#39;, 4), (&#39;one&#39;, 1)])
</code></pre>

<h2 id="toc_27">defaultdict(默认字典)</h2>

<p>使用字典的时候，如果某个key不存在而被访问，程序会报错。如果希望如果希望key不存在时，返回一个默认值，就可以用defaultdict。</p>

<h3 id="toc_28">defaultdict()方法的使用</h3>

<p>该方法接受两个参数，第一个参数是一个数据类型，代表当访问的key不存在时，默认返回一个什么类型的数据，第二个参数是初始化的字典数据</p>

<p>示例代码</p>

<pre><code class="language-python">from collections import defaultdict

di = defaultdict(tuple, {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3})
print(di[&quot;four&quot;])
print(di)
</code></pre>

<p>参考结果</p>

<pre><code class="language-python">()
defaultdict(&lt;class &#39;tuple&#39;&gt;, {&#39;two&#39;: 2, &#39;four&#39;: (), &#39;one&#39;: 1, &#39;three&#39;: 3})
</code></pre>

<h2 id="toc_29">个人感悟</h2>

<p>collections模块中常用的功能有namedtuple, deque, Counter, OrderedDict和defaultdict.</p>

<ul>
<li>namedtuple一般用于对元素不会进行修改，并且需要对每个元素有一个属性名。</li>
<li>deque是一个双列表，解决列表两端读取和删除的性能问题，和列表的绝大多数操作方法一致，有一些是队列特有的左端元素操作方法。</li>
<li>Counter类用于对元素出现的次数进行计算，可以用于统计一个字符串中每个字符出现的次数。</li>
<li>OrderedDict类用于对字典进行顺序确定，能够保证字典中元素的顺序是元素添加的顺序。</li>
<li>defaultdict类用于给字典中没有出现的元素一个默认值类型，保证在获取不到某个元素值的时候程序能够正常运行。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python对列表进行操作]]></title>
    <link href="http://blog.yanzl.net/14724629382123.html"/>
    <updated>2016-08-29T17:28:58+08:00</updated>
    <id>http://blog.yanzl.net/14724629382123.html</id>
    <content type="html"><![CDATA[
<p><strong>:Python3不可以对类似于[1,2,&#39;sjsu&#39;]列表进行排序，而2是支持的～</strong></p>

<p>列表是可以被改变的,所以当对列表进行修改的时候,所对应的id是不变的,这和字符串不同</p>

<h4 id="toc_0">定义列表</h4>

<ul>
<li>l[]</li>
<li>l = [&#39;22&#39;,&#39;erer&#39;,[1,2]]</li>
<li>l = list(&#39;cjdhfy&#39;)</li>
<li>l = [x**2 for x in range(l[2:6])]
#### 查找元素</li>
<li>l[i],若i大于len(l),则返回错误(IndexError)</li>
<li>l[i][j]</li>
<li>顺便查看元素下标：for index, value in enumerate(I): print(index, value)
#### 查看长度
len(l)
#### 切片
l[x:y],如果x大于y,或者读取的范围大于l的长度,则返回空列表  .
#### 列表拼接:</li>
<li>+代表两个列表进行拼接，两边必须是相同类型的序列，比如一个列表，一个是字符串，这样是没有办法直接相加的，必须转换成相同类型</li>
<li>*代表将列表重复
#### 判断是否存在
x in l
#### 添加元素:</li>
<li>append()  l.append(),添加一个元素</li>
<li>extend()    l.extend(),可以添加多个元素,[]括起来,元素之间以,分割
#### 插入元素:insert()<br/>
l.insert(x,y),在索引为x的地方插入元素y
#### 查找元素所在位置
index()     l.index(y),查找元素y的索引,如果没有该元素,则会报错(ValueError)
#### 查看某一个元素出现的次数
count()   l.count(),只能查找某一个元素,如果没有返回0
#### 反转列表:</li>
<li>reversed()     list(reversed(l)),该方法转换之后的格式并不是list,需要进行转换格式</li>
<li>reverse()  l.reverse()
#### 删除元素:del</li>
<li>del l[k] 删除l的第k个元素</li>
<li>del l[k:m] 删除从第k个元素开始,到第m(不包括m)个元素,如果没有m,则删除k之后的内容.</li>
<li>l[i:j] = []    删除从第i个元素开始,到第j(不包括j)个元素</li>
<li>l.pop()   删除列表的最后一个元素</li>
<li>l.remove(s) 移除s元素
#### 修改元素: 
l[索引] = 修改的值
#### 排序:    l.sort(),默认会从小到大排序,如果要从大到小排序,则l.sort(reverse=True)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Time模块]]></title>
    <link href="http://blog.yanzl.net/14720317525979.html"/>
    <updated>2016-08-24T17:42:32+08:00</updated>
    <id>http://blog.yanzl.net/14720317525979.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">常用方法介绍</h2>

<ul>
<li><strong>time.localtime()：</strong>将一个时间戳转换成一个当前时区的struct_time</li>
<li><strong>time.mktime()：</strong>将struct_time类型时间转换成时间戳</li>
<li><strong>time.sleep(secs)：</strong>进程休眠secs秒</li>
<li><strong>time.strftime(format, t)：</strong>将指定的struct_time(默认为当前时间)，根据指定的格式化字符串输出，t未指定，传入time.localtime()作为默认参数</li>
<li><strong>time.strptime(str_t, format)：</strong>将格式化字符串转换成struct_time数据，format参数的格式必须与str_t的格式对应</li>
<li><strong>time.time()：</strong>获取当前时间的时间戳</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python3  获取中文的首字母]]></title>
    <link href="http://blog.yanzl.net/14857054898000.html"/>
    <updated>2017-01-29T23:58:09+08:00</updated>
    <id>http://blog.yanzl.net/14857054898000.html</id>
    <content type="html"><![CDATA[
<p>前话</p>

<p>python 3中只有unicode str，所以把decode方法去掉了，所以如果要获取中文的首字母就不需要繁琐的decode转换方法。<br/>
encode()方法可以将Unicode编码转换成指定的编码格式，这里是将Unicode转换成gbk的编码，如果是中文的话，也可以指定gb2312，不过gbk支持的中文会更多<br/>
应该知道的一点是每个中文占两个字节<br/>
基本思路</p>

<p>首先把中文字符串转换成gbk格式的编码，这个时候会是一串字节码<br/>
循环遍历字节码,每一个循环会得到每个字节相应的ascii码,判断是否对应大小写字母，如果是字母，则直接转换<br/>
如果是汉字，则每两个字节做一次汉字转换，获取首字母<br/>
存在的问题</p>

<p>因为不熟悉汉字中的每个字节对应的ascii关系，所以这里只处理了汉字和字母，如果字符串中存在英文字符，则无法显示正确结果，如果有大神知道解决方案，欢迎给出评论指导，博主也会尽快查找资料填补这部分漏洞。</p>

<p>执行代码</p>

<p>def get_head_letter(str_input):<br/>
    str_input = str_input.encode(&#39;gbk&#39;)<br/>
    print(type(str_input))<br/>
    print(str_input)<br/>
    return_list = []<br/>
    num = 0<br/>
    for one_unicode in str_input:<br/>
        if (one_unicode &gt;= 97 and one_unicode &lt;= 122) or (one_unicode &gt;= 65 and one_unicode &lt;= 90):<br/>
            return_list.append(chr(one_unicode))<br/>
            continue<br/>
        print(type(one_unicode))<br/>
        print(one_unicode)<br/>
        if num == 0:<br/>
            first = one_unicode<br/>
            num += 1<br/>
        elif num == 1:<br/>
            last = one_unicode<br/>
            num += 1<br/>
        if num == 2:<br/>
            num = 0<br/>
            return_list.append(single_letter(first, last))<br/>
    return return_list</p>

<p>def single_letter(first, last):<br/>
    asc = first * 256 + last - 65536<br/>
    if asc &gt;= -20319 and asc &lt;= -20284:<br/>
        return &#39;a&#39;<br/>
    if asc &gt;= -20283 and asc &lt;= -19776:<br/>
        return &#39;b&#39;<br/>
    if asc &gt;= -19775 and asc &lt;= -19219:<br/>
        return &#39;c&#39;<br/>
    if asc &gt;= -19218 and asc &lt;= -18711:<br/>
        return &#39;d&#39;<br/>
    if asc &gt;= -18710 and asc &lt;= -18527:<br/>
        return &#39;e&#39;<br/>
    if asc &gt;= -18526 and asc &lt;= -18240:<br/>
        return &#39;f&#39;<br/>
    if asc &gt;= -18239 and asc &lt;= -17923:<br/>
        return &#39;g&#39;<br/>
    if asc &gt;= -17922 and asc &lt;= -17418:<br/>
        return &#39;h&#39;<br/>
    if asc &gt;= -17417 and asc &lt;= -16475:<br/>
        return &#39;j&#39;<br/>
    if asc &gt;= -16474 and asc &lt;= -16213:<br/>
        return &#39;k&#39;<br/>
    if asc &gt;= -16212 and asc &lt;= -15641:<br/>
        return &#39;l&#39;<br/>
    if asc &gt;= -15640 and asc &lt;= -15166:<br/>
        return &#39;m&#39;<br/>
    if asc &gt;= -15165 and asc &lt;= -14923:<br/>
        return &#39;n&#39;<br/>
    if asc &gt;= -14922 and asc &lt;= -14915:<br/>
        return &#39;o&#39;<br/>
    if asc &gt;= -14914 and asc &lt;= -14631:<br/>
        return &#39;p&#39;<br/>
    if asc &gt;= -14630 and asc &lt;= -14150:<br/>
        return &#39;q&#39;<br/>
    if asc &gt;= -14149 and asc &lt;= -14091:<br/>
        return &#39;r&#39;<br/>
    if asc &gt;= -14090 and asc &lt;= -13119:<br/>
        return &#39;s&#39;<br/>
    if asc &gt;= -13118 and asc &lt;= -12839:<br/>
        return &#39;t&#39;<br/>
    if asc &gt;= -12838 and asc &lt;= -12557:<br/>
        return &#39;w&#39;<br/>
    if asc &gt;= -12556 and asc &lt;= -11848:<br/>
        return &#39;x&#39;<br/>
    if asc &gt;= -11847 and asc &lt;= -11056:<br/>
        return &#39;y&#39;<br/>
    if asc &gt;= -11055 and asc &lt;= -10247:<br/>
        return &#39;z&#39;<br/>
    return &#39;&#39;</p>

<p>def main(str_input):<br/>
    a = get_head_letter(str_input)<br/>
    print(a)<br/>
    b = &#39;&#39;<br/>
    for i in a:<br/>
        b = b + i<br/>
    print(b)</p>

<p>if <strong>name</strong> == &quot;__main__&quot;:<br/>
    str_input = &#39;A测试获取c中文首字母,js&#39;<br/>
    main(str_input)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery中的ajax实现异步请求]]></title>
    <link href="http://blog.yanzl.net/14702800236946.html"/>
    <updated>2016-08-04T11:07:03+08:00</updated>
    <id>http://blog.yanzl.net/14702800236946.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">使用背景</h2>

<p>在页面显示中，我们希望点击一个按钮获取到相应数据后，在当前页面显示数据而不是跳转到新的页面去显示数据。或者在做一个操作后（比如删除，修改等操作），当前页面不会重新加载，但是会将操作传递到后台进行操作，这个时候我们就会用到异步请求。使用jQuery集成的ajax进行异步操作还是蛮方便的。</p>

<h2 id="toc_1">常用参数</h2>

<p><strong>注 ajax的请求参数都是以键值对的方式存在的</strong></p>

<ul>
<li>url：发送请求的路径</li>
<li>type：请求的类型，get，post（jQuery有对这两种请求类型的封装：\(.get()，\).post()），delete，put，head，trach，请求类型是可以自定义的，但有的浏览器是不支持的</li>
<li>dataType：告诉服务器要返回的数据类型，一般类型为：xml, html, json(必须是正确的格式，否则会抛出解析错误异常), script(响应结果当做javascript执行，在跨域请求时，请求方式强制为GET)，text，jsonp</li>
<li>async：默认会为True，即发送异步请求，如果发送同步请求，将此项改为False（不过此方法在jQuery1.8之后好像过时了）</li>
<li>cache：默认会为True，即浏览器缓存此页面，如果是False（dataType为script和jsonp会默认False）</li>
<li>contentType：发送信息至服务器时内容编码类型，默认值是“application/x-www-form-urlencoded; charset=UTF-8”，有时要在服务器端进行适当的解码</li>
<li>crossDomain：同域请求为False，跨域请求为True，默认为False</li>
<li>data：发送到服务器的数据，会自动转化为请求字符串格式，键值对形式存在</li>
<li>beforeSend：请求发送前的回调函数，一般会用来设置自定义和http请求头信息，在该函数中返回false会取消这个请求</li>
<li>success：请求成功后会回调该函数</li>
<li>error：请求失败后会回调该函数</li>
<li>headers：设置请求头的信息，如果在beforeSend中也设置了相应头信息，则headers中会被覆盖</li>
<li>password：用于响应http访问认证请求的密码</li>
<li>username：用于响应http访问认证请求的用户名。</li>
</ul>

<h2 id="toc_2">使用示例</h2>

<pre><code class="language-javascript">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;
        function get_comment(button) {
            var id = button.getAttribute(&quot;id&quot;);
            $.ajax({
                type: &quot;GET&quot;,
                url: &quot;/api/user/detail&quot;,
                data: {
                    &#39;id&#39;: id
                },
                dataType: &#39;json&#39;,
                success: function (result) {
                    console.log(&quot;请求成功，获取数据&quot;)
                }
            });
        }
    &lt;/script&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flask-RESTful 请求解析 ☞ reqparse]]></title>
    <link href="http://blog.yanzl.net/14701068705193.html"/>
    <updated>2016-08-02T11:01:10+08:00</updated>
    <id>http://blog.yanzl.net/14701068705193.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">使用背景</h2>

<p>对于一个请求中的参数，我们可以使用request.form,request.args,request.get_json()等方法将需要的数据提取出来，但是很多情况下这些数据都是不可信的，所以我们需要一一验证，在参数比较多的情况下，依次验证就显得麻烦很多，这个时候我们可以使用Flask-RESTful提供的请求解析模块——reqparse</p>

<h2 id="toc_1">定义对象</h2>

<pre><code class="language-python">from flask_restful import reqparse

parser = reqparse.RequestParser()
</code></pre>

<h2 id="toc_2">添加解析器</h2>

<pre><code class="language-python">parser.add_argument(&#39;name&#39;, type=str, default=1, required=True, ignore=True, 
location=&#39;args&#39;, choices=(&#39;bob&#39;,&#39;since&#39;), case_sensitive=False, 
store_missing=True)
</code></pre>

<p>对添加数据约束时的各个参数做一个简单的介绍：</p>

<ul>
<li>type:数据的类型，int，str，text，werkzeug.datastructures.FileStorage（files中读数据）等</li>
<li>default:如果请求中不带有该参数，则取该默认值作为参数值</li>
<li>required:值为True的情况下，规定必须包含该参数，否则报请求错误</li>
<li>ignore：值为True的情况下，如果参数类型发生转变，则会忽略该参数，即参数值为None</li>
<li>choices: 参数值在选择池中，如果不在选择池中，则报请求错误</li>
<li>case_sensitive: 值为True的情况下，会区分大小写，值为False的情况下，大写转小写</li>
<li>store_missing:个人测试好像和default配合使用才会起作用， 在没有默认值的情况下，无论该变量的值是True还是False，其数据的值都是None，在有默认值的情况下，store_missing为True时，如果请求中没有出现该参数，则存储默认值。</li>
<li>location：指明参数的位置，比如：form, args, headers, cookies, files等，需要注意的是有的位置要指明参数的类型，如果一个参数可能存在多个位置，可以以列表的形式指明location，最后的结果会先在列表指定的位置查找，找不到的话或在其他地方查找</li>
<li>trim:设置为True的情况下，会清除参数中的前置后置空格</li>
<li>nullable：设置为True的情况下，会允许接受的值为None</li>
<li>help：帮助文字，在参数出问题的情况下会显示该内容</li>
<li>action：The basic type of action to be taken when this argument is encountered in the request. Valid options are “store” and “append”.</li>
<li>dest：参数解析时返回的参数名</li>
<li>name：参数名，有可选和必选之分。</li>
</ul>

<h2 id="toc_3">解析器继承</h2>

<p>有时候会有多个公共参数，这时候如果没每个请求都写一个解析器，则可能会有很多代码是重复的，所以可以指定一个父解析器，然后去继承这个解析器。</p>

<pre><code class="language-python">from flask_restful import reqparse

parser = reqparse.RequestParser()

parser.add_argument(&#39;name&#39;, type=str)
parser.add_argument(&#39;weight&#39;, type=int, required=True)
parser.add_argument(&#39;height&#39;, type=int)

# 使用parser.copy()方法扩展parser解析器
parser_copy = parser.copy()
#添加新的参数
parser_copy.add_argument(&#39;age&#39;, type=int)
#replace_argument()方法重写某个参数的解析约束
parser_copy.replace_argument(&#39;weight&#39;, type=int)
#remove_argument()方法删除某个参数
parser_copy.remove_argument(&#39;height&#39;)
</code></pre>

<h2 id="toc_4">执行参数解析与获取参数值</h2>

<p>这里直接写参数解析，上文请参考定义对象和添加解析器</p>

<pre><code class="language-python">args = parser.parse_args()
name = args.get(&quot;name&quot;)
</code></pre>

<p><strong>注</strong> python中还有一个命令解析模块，请求解析是仿照命令解析编写的</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Datatime模块]]></title>
    <link href="http://blog.yanzl.net/14700447941589.html"/>
    <updated>2016-08-01T17:46:34+08:00</updated>
    <id>http://blog.yanzl.net/14700447941589.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">datetime.timedelta</h2>

<p>用于表示两个datetime.date, datetime.time或者datetime.datetime之间的时间差,类的原型为：</p>

<pre><code class="language-python">class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0,
 minutes=0, hours=0, weeks=0)
</code></pre>

<p>timedelta可以指定一个时间段，规定该时间段有多少天、秒、毫秒、微秒、分钟、小时、周，从而对该时间段进行一些操作，整理了以下几点：</p>

<ul>
<li><strong>加减法：</strong>可以将两个时间段做加减法，得到一个新的时间段。另外，可以将datetime.datetime类型或者datetime.date类型的数据进行加减法</li>
<li><strong>乘法：</strong>可以将一个时间段和一个常数进行乘法操作，像普通乘法一样</li>
<li><strong>除法：</strong>可以将一个时间段与一个常数进行除法操作,返回是一个timedelta类型的数据</li>
<li><strong>取正数结果：</strong>abs()函数可以在运行结果为负数时返回正数结果,注意这里不是绝对值，而是会将两个操作数交换顺序进行运算。（比如a-b&lt;0,则返回的结果为b-a的结果）</li>
<li><strong>返回字符串类型数据：</strong>以上的操作返回的数据类型都是timedelta类型的，如果希望返回字符串类型，可以使用str()函数</li>
<li><strong>返回所有秒数：</strong>可以设定一个时间段，返回该时间段的所有秒数</li>
<li><strong>获取可取时间段的最大值：</strong>可以使用timedelta.max方法进行获取</li>
<li><p><strong>获取可取时间段的最小值：</strong>可以使用timedelta.min方法进行获取</p>

<p><strong>注 除法不能执行数字除以timedelta类型的操作， 乘法和除法操作都不能是两个timedelta类型的数据</strong></p></li>
</ul>

<h3 id="toc_1">示例代码</h3>

<pre><code class="language-python">from datetime import timedelta

timedelta1 = timedelta(days=1, hours=2, minutes=10)
timedelta2 = timedelta(days=2, hours=4, minutes=20, seconds=10)

print(timedelta1 + timedelta2)
print (timedelta2 - timedelta1)
print (timedelta2 * 2)
print (2 * timedelta2)
print (timedelta2 / 2)
print (abs(timedelta1 - timedelta2))
print (str(timedelta1 - timedelta2))
print (type(timedelta2 / 2))
print (type(str(timedelta2 / 2)))
print (type(repr(timedelta2 / 2)))
print (timedelta2.total_seconds())
print timedelta.max
print timedelta.min
</code></pre>

<h3 id="toc_2">示例运行结果</h3>

<pre><code>3 days, 6:30:10
1 day, 2:10:10
1 day, 2:10:10
-2 days, 21:49:50
4 days, 8:40:20
4 days, 8:40:20
1 day, 2:10:05
&lt;type &#39;datetime.timedelta&#39;&gt;
&lt;type &#39;str&#39;&gt;
&lt;type &#39;str&#39;&gt;
188410.0
999999999 days, 23:59:59.999999
-999999999 days, 0:00:00
</code></pre>

<h2 id="toc_3">datetime.time</h2>

<p>表示时间信息，类的原型为：</p>

<pre><code class="language-python">class datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None)
</code></pre>

<h3 id="toc_4">类的属性</h3>

<ul>
<li>time.min</li>
<li>time.max</li>
<li>time.resolution</li>
<li>time.hour</li>
<li>time.minute</li>
<li>time.second</li>
<li>time.microsecond</li>
<li>time.tzinfo</li>
</ul>

<h3 id="toc_5">运算操作</h3>

<ol>
<li>进行两个time类型数据的比较</li>
</ol>

<h3 id="toc_6">对象操作</h3>

<ul>
<li><strong>修改time类型数据：</strong> time_data.replace(hour=13, minute=25)</li>
<li><strong>转换成ISO格式数据:</strong> time_data.isoformat()</li>
<li><strong>格式化time类型数据：</strong> time_data.strftime(&#39;%Y/%m/%d %H:%M:%S&#39;),注意，因为time类型数据没有年月日，所以在数据类型转换时如果出现年月日，默认为1900/01/01</li>
</ul>

<h3 id="toc_7">对象操作示例</h3>

<pre><code class="language-python">time_data = time(12, 13, 14, 15)
print time_data
time_data_replace = time_data.replace(hour=13, minute=25)
print time_data_replace
time_data_isoformat = time_data.isoformat()
print time_data_isoformat
time_data_strftime = time_data.strftime(&#39;%Y/%m/%d %H:%M:%S&#39;)
print time_data_strftime
</code></pre>

<h3 id="toc_8">示例参考结果</h3>

<pre><code>12:13:14.000015
13:25:14.000015
12:13:14.000015
1900/01/01 12:13:14
</code></pre>

<h2 id="toc_9">datatime.date</h2>

<p>用于返回日期的时间（年，月，日），类的原型为：</p>

<pre><code class="language-python">class datetime.date(year, month, day)
</code></pre>

<h3 id="toc_10">类的属性</h3>

<ul>
<li>date.min</li>
<li>date.max</li>
<li>date.resolution 计算date类型的精度</li>
<li>date.year</li>
<li>date.month</li>
<li>date.day</li>
</ul>

<h3 id="toc_11">运算操作</h3>

<ol>
<li>date类型数据与timedelta类型数据进行加减运算,得到的数据类型为date</li>
<li>两个date类型数据相减，得到的数据类型为timedelta</li>
<li>比较大小，返回布尔值</li>
</ol>

<h3 id="toc_12">常见类操作</h3>

<ul>
<li><strong>计算当天日期：</strong> date.today()</li>
<li><strong>根据时间戳获取某一时间：</strong> date.fromtimestamp(timestamp)</li>
<li><strong>根据天数返回对应的日期：</strong>date.fromordinal(),与对象方法toordinal()相对应</li>
</ul>

<h3 id="toc_13">类操作示例</h3>

<pre><code class="language-python">today = date.today()
today_from_timestamp = date.fromtimestamp(time.time())
date_from_ordinal = date.fromordinal(736191)
print date.today()
print today_from_timestamp
print date.fromordinal(736191)
</code></pre>

<h3 id="toc_14">示例参考结果</h3>

<pre><code>2016-08-15
2016-08-15
2016-08-15
</code></pre>

<h3 id="toc_15">常见对象方法</h3>

<ul>
<li><strong>修改某个日期：</strong> 可以通过date.replace()方法重写year,month,day参数改变日期</li>
<li><strong>转换成time.struct_time类型数据：</strong>date.timetuple()方法可以实现该转换，等同于time.localtime()</li>
<li><strong>计算当天是一周的第几天：</strong>date.weekday(),返回0~6; date.isoweekday()，返回1~7</li>
<li><strong>计算当天是哪一年第几周的周几：</strong> date.isocalendar(),返回一个元组。</li>
<li><strong>将日期转换成iso格式：</strong>date.isoformat(),格式为：2016-08-14</li>
<li><strong>格式化日期：</strong> date.strftime()</li>
<li><strong>返回某日期距离1年1月1日的天数：</strong>date.toordinal()</li>
</ul>

<p><strong>这里有一个疑问：isocalendar方法中一年的第一周到底是如何计算的~~</strong></p>

<h3 id="toc_16">示例代码</h3>

<pre><code class="language-python">today = date.today()
today_replace = today.replace(month=12, day=14)
print today
print today_replace
today_timetuple = today.timetuple()
time_localtime = time.localtime()
print today_timetuple
print time_localtime
print type(today_timetuple), type(time_localtime)
today_weekday = today.weekday()
today_iso_weekday = today.isoweekday()
print today_weekday
print today_iso_weekday
today_iso_format = today.isoformat()
print today_iso_format
today_strftime = today.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)
print today_strftime
today_toordinal = today.toordinal()
print today_toordinal
today_iso_calendar = today.isocalendar()
print today_iso_calendar
print date(2014, 1, 1).isocalendar()
print date(2016, 1, 1).isocalendar()
</code></pre>

<h3 id="toc_17">示例参考结果</h3>

<pre><code>2016-08-15
2016-12-14
time.struct_time(tm_year=2016, tm_mon=8, tm_mday=15, tm_hour=0, tm_min=0,
 tm_sec=0, tm_wday=0, tm_yday=228, tm_isdst=-1)
time.struct_time(tm_year=2016, tm_mon=8, tm_mday=15, tm_hour=13, tm_min=48,
 tm_sec=35, tm_wday=0, tm_yday=228, tm_isdst=0)
&lt;type &#39;time.struct_time&#39;&gt; &lt;type &#39;time.struct_time&#39;&gt;
0
1
2016-08-15
2016-08-15 00:00:00
736191
(2016, 33, 1)
(2014, 1, 3)
(2015, 53, 5)
</code></pre>

<h2 id="toc_18">datetime.datetime</h2>

<p>用于返回日期和时间，相当于date和time的合体，类的原型为：</p>

<pre><code class="language-python">class datetime.datetime(year, month, day, hour=0, minute=0, second=0,
 microsecond=0, tzinfo=None)
</code></pre>

<h3 id="toc_19">类的属性包括：</h3>

<ul>
<li>datetime.min</li>
<li>datetime.max</li>
<li>datetime.year</li>
<li>datetime.month</li>
<li>datetime.day</li>
<li>datetime.hour</li>
<li>datetime.minute</li>
<li>datetime.second</li>
<li>datetime.microsecond</li>
<li>datetime.tzinfo</li>
<li>datetime.resolution: 计算类的精确度</li>
</ul>

<h3 id="toc_20">类的运算</h3>

<ol>
<li>datetime类型与timedelta类型做加减运算</li>
<li>两个datetime类型数据做减法运算，得到timedelta类型的结果</li>
<li><p>比较两个datetime类型数据的大小</p>

<h3 id="toc_21">常见类操作如下：</h3></li>
</ol>

<ul>
<li><strong>计算当天日期时间：</strong> datetime.today(),该方法不包含时区信息</li>
<li><strong>计算当前日期时间：</strong> datetime.now([tz]),该方法中有一个参数用来接收时区，如果没有，则结果和today()相同，如果有时区信息，则该时区必须是tzinfo的一个具体实例</li>
<li><strong>计算当时UTC时间：</strong> datetime.utcnow(),UTC时间是世界标准时间，比北京时间慢8小时，因为北京处于东八区</li>
<li><strong>将时间戳转换成datetime格式：</strong> datetime.fromtimestamp(timestamp),这里第二个参数可以设置转换时区，默认会是本地日期和时间</li>
<li><strong>将时间戳转化为UTC时间：</strong> datetime.utcfromtimestamp(timestamp)，返回的是世界标准时间</li>
<li><strong>根据天数获取对应的日期：</strong> datetime.fromordinal(days)</li>
<li><strong>合并日期和时间为日期时间：</strong> datetime.combine(date, time)</li>
<li><strong>将字符串类型转换成datetime类型：</strong> datetime.strptime(today_strftime, &#39;%Y-%m-%d %H:%M:%S&#39;)，注意这里的第二个参数，与第一个参数的格式必须一致才能够成功转换</li>
</ul>

<h3 id="toc_22">类操作示例</h3>

<pre><code class="language-python">today = datetime.today()
now = datetime.now(tz=None)
utcnow = datetime.utcnow()
print today
print now
print utcnow
today_from_timestamp = datetime.fromtimestamp(1471230039.49)
print today_from_timestamp
today_from_utctimestamp = datetime.utcfromtimestamp(1471230039.49)
print today_from_utctimestamp
days = datetime.fromordinal(736199)
print days
type_date = date.today()
type_time = date_time(11,30,59)
combine_date_time = datetime.combine(type_date, type_time)
print combine_date_time
today_strftime = today.strftime(&#39;%Y/%m/%d %H:%M:%S&#39;)
today_strptime = datetime.strptime(today_strftime, &#39;%Y/%m/%d %H:%M:%S&#39;)
print today_strftime
print today_strptime
print type(today_strftime)
print type(today_strptime)
</code></pre>

<h3 id="toc_23">类操作示例参考结果</h3>

<pre><code>2016-08-15 11:28:41.109749
2016-08-15 11:28:41.109829
2016-08-15 03:28:41.109832
2016-08-15 11:00:39.490000
2016-08-15 03:00:39.490000
2016-08-23 00:00:00
2016-08-15 11:30:59
2016/08/15 11:28:41
2016-08-15 11:28:41
&lt;type &#39;str&#39;&gt;
&lt;type &#39;datetime.datetime&#39;&gt;
</code></pre>

<h3 id="toc_24">常见对象操作方法如下：</h3>

<p>先来创建一个对象：<code>today = datetime.today()</code></p>

<ul>
<li><strong>返回datetime的日期值：</strong>today.date()可以返回日期值,返回值为date类型</li>
<li><strong>返回detetime的时间值：</strong>today.time()可以相同的时间返回时间值; today.timetz()，使用相同的时间和时区返回时间值，时区为None时不返回时区。两种方法返回值类型都为time类型。</li>
<li><strong>修改日期时间：</strong> today.replace()方法可以实现对日期时间进行修改，没有修改的属性还是维持原来的值</li>
<li><strong>将datetime类型数据解析成struc_time结构体返回：</strong> today.timetuple()返回当前时间的解析结构体；today.utctimetuple()返回utc时间的解析结构体</li>
<li><strong>获取当前日期距离1年1月1日的天数：</strong> today.toordinal(),与类方法datetime.fromordinal(days)相对应</li>
<li><strong>返回当前日期的星期：</strong> today.weekday(),返回值0~6；today_isoweekday（），返回值1~7</li>
<li><strong>返回当前年份，周数，星期：</strong>today.isocalendar(),返回一个三元组，包括年，第几周，周几</li>
<li><strong>返回ISO格式日期时间：</strong>datetime.isoformat(today)，个人认为这更像一个类方法。</li>
<li><strong>转换成time.ctime的数据格式:</strong> today.ctime()</li>
<li><strong>根据格式转换成字符串类型：</strong> today.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;),默认格式为ISO-8601,与类方法datetime.strptime()相对应</li>
</ul>

<h3 id="toc_25">对象方法示例</h3>

<pre><code class="language-python">today = datetime.today()
today_date = today.date()
today_time = today.time()
today_timetz = today.timetz()
print today_date
print today_time
print today_timetz
today_replace = today.replace(year=2016, day=23, minute=34, second=34)
print today_replace
today_struct_time = today.timetuple()
today_utc_struct_time = today.utctimetuple()
print today_struct_time
print today_utc_struct_time
today_days = today.toordinal()
print today_days
today_weekday = today.weekday()
today_isoweekday = today.isoweekday()
print today_weekday
print today_isoweekday
today_isoclaendar = today.isocalendar()
print today_isoclaendar
today_isoformat = datetime.isoformat(today)
print today_isoformat
today_ctime = today.ctime()
print today_ctime
today_strftime = today.strftime(&#39;%Y/%m/%d %H:%M:%S&#39;)
print today_strftime
</code></pre>

<h3 id="toc_26">对象操作方法示例参考结果</h3>

<pre><code>2016-08-15
13:15:15.692802
13:15:15.692802
2016-08-23 13:34:34.692802
time.struct_time(tm_year=2016, tm_mon=8, tm_mday=15, tm_hour=13, tm_min=15,
 tm_sec=15, tm_wday=0, tm_yday=228, tm_isdst=-1)
time.struct_time(tm_year=2016, tm_mon=8, tm_mday=15, tm_hour=13, tm_min=15,
 tm_sec=15, tm_wday=0, tm_yday=228, tm_isdst=0)
736191
0
1
(2016, 33, 1)
2016-08-15T13:15:15.692802
Mon Aug 15 13:15:15 2016
2016/08/15 13:15:15
</code></pre>

<h3 id="toc_27">格式转换</h3>

<h3 id="toc_28">符号说明表</h3>

<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>%y</td>
<td>两位数的年份表示（0~99）</td>
</tr>
<tr>
<td>%Y</td>
<td>四位数的年份表示（000~9999）</td>
</tr>
<tr>
<td>%m</td>
<td>月份</td>
</tr>
<tr>
<td>%d</td>
<td>月中的一天</td>
</tr>
<tr>
<td>%I</td>
<td>十二小时制的小时（1~12）</td>
</tr>
<tr>
<td>%H</td>
<td>二十四小时制的小时（0~23）</td>
</tr>
<tr>
<td>%M</td>
<td>每小时内的分钟（0~59）</td>
</tr>
<tr>
<td>%S</td>
<td>每分钟的秒（0~59）</td>
</tr>
<tr>
<td>%b</td>
<td>当地月份简写</td>
</tr>
<tr>
<td>%B</td>
<td>当地月份全称</td>
</tr>
<tr>
<td>%c</td>
<td>本地相应的日期表示和时间表示</td>
</tr>
<tr>
<td>%x</td>
<td>本地相应的日期表示</td>
</tr>
<tr>
<td>%X</td>
<td>本地相应的时间表示</td>
</tr>
<tr>
<td>%a</td>
<td>本地星期简写</td>
</tr>
<tr>
<td>%A</td>
<td>本地星期全称</td>
</tr>
<tr>
<td>%U</td>
<td>一年中的星期数（00-53）星期天为星期的开始</td>
</tr>
<tr>
<td>%W</td>
<td>一年中的星期数（00-53）星期一为星期的开始</td>
</tr>
<tr>
<td>%w</td>
<td>星期（0-6），星期天为星期的开始</td>
</tr>
<tr>
<td>%j</td>
<td>当天是全年的第几天</td>
</tr>
<tr>
<td>%z</td>
<td>该时间使用的时区，如果没有指定，则为None</td>
</tr>
<tr>
<td>%%</td>
<td>%本身</td>
</tr>
</tbody>
</table>

<h3 id="toc_29">转换符示例</h3>

<pre><code class="language-python">today = datetime.today()
print today.strftime(&#39;%y-%m-%d %p.%I:%M:%S&#39;)
date_strftime = today.replace(hour=0, minute=12, second=0).strftime(&#39;%Y-%m-%d %I:%M:%S&#39;)
print date_strftime
print today.strftime(&#39;%Y/%m%d %H:%M:%S&#39;)
print today.strftime(&#39;%b / %B&#39;)
print today.strftime(&#39;%c&#39;)
print today.strftime(&#39;%x&#39;)
print today.strftime(&#39;%X&#39;)
print today.strftime(&#39;%a / %A&#39;)
print today.strftime(&#39;%Y %U %w&#39;)
print today.strftime(&#39;%Y %W %w&#39;)
print today.strftime(&#39;%j&#39;)
print today.strftime(&#39;%Z&#39;)
print today.strftime(&quot;%%&quot;)
</code></pre>

<h3 id="toc_30">示例参考结果</h3>

<pre><code>16-08-15 PM.02:51:32
2016-08-15 12:12:00
2016/0815 14:51:32
Aug / August
Mon Aug 15 14:51:32 2016
08/15/16
14:51:32
Mon / Monday
2016 33 1
2016 33 1
228

%
</code></pre>

<h2 id="toc_31">个人感悟</h2>

<p>datetime模块包含timedelta，date，datetime，time， tzinfo， 五个类构成,timedelta提供日期时间计算的中间量；date用于对日期进行操作；time用于对时间进行操作（但是没有获取当前时间的操作），datetime是日期和时间的合体，既有日期也有时间，并且可以单独获取某个日期时间的日期和时间，是继承自date类的类；tzinfo类用于对时区进行操作，但这个类是一个基类，如果要使用，必须创建实体类.<br/>
无论是date类，datetime类，还是time类，都有一些实现相同功能的方法，不过不同的类具体的参数不同：<br/>
obj.replace():用来修改日期时间<br/>
obj.rsoformat():用来显示ISO-8601格式的时间<br/>
obj.strftime():将相应对象转换成所接受的格式的字符串</p>

<p>datetime类继承自date类，有些方法名称和效果是一样的：<br/>
cls.today()，获取当前时间<br/>
cls.fromtimestamp(),根据时间戳获取时间<br/>
cls.fromordinal(),根据天数获取相应时间<br/>
obj.toordinal(),获取当前日期距离1年1月1日的总天数<br/>
obj.timetuple(),获取当前日期的time.struct_time格式数据<br/>
obj.weekday(),获取当前日期的星期，0~6<br/>
obj.isoweekday(),获取当前日期的星期，1~7<br/>
obj.isocalendar(),以三元组的形式获取日期年份，在这一年的星期数，当前星期的星期几</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python命令行参数解析☞argparse、请求解析☞reqparse]]></title>
    <link href="http://blog.yanzl.net/14696161345629.html"/>
    <updated>2016-07-27T18:42:14+08:00</updated>
    <id>http://blog.yanzl.net/14696161345629.html</id>
    <content type="html"><![CDATA[
<p>这篇文章是对命令行参数解析和请求解析的总结，因为都是对传递的参数进行的解析，所以写在了一起，可以对比一下。但是两种解析的来源是不一样的，argparse来自python的自带模块，reqparse来自于Flask-RESTful扩展</p>

<h1 id="toc_0">Python命令行参数解析☞argparse</h1>

<h2 id="toc_1">简介</h2>

<p>对于命令行参数解析，最原始的方法是手动解析，解析过程如下所示：</p>

<pre><code class="language-python">import sys
def TestSys():
  for arg in sys.argv[1:]:
    print (arg)
</code></pre>

<p>argparse是python自带的模块，利用argparse，可以完成对命令行的参数定义、解析以及后续的处理。</p>

<h2 id="toc_2">创建一个解析器</h2>

<pre><code class="language-python">import argparse
parser = argparse.ArgumentParser(description=&#39;Process some integers.&#39;)
</code></pre>

<h2 id="toc_3">添加解析参数前置知识☞属性</h2>

<ul>
<li>help：帮助信息</li>
<li>type：数据类型，str,int等</li>
<li>choices：参数值可选范围</li>
<li>action：参数动作，在解析到一个参数时进行触发的动作

<ul>
<li>store 保存参数值，可能会先将参数值转换成另一个数据类型。若没有显式指定动作，则默认为该动作。</li>
<li>store_const 保存一个被定义为参数规格一部分的值，而不是一个来自参数解析而来的值。这通常用于实现非布尔值的命令行标记。</li>
<li>store_ture/store_false 保存相应的布尔值。这两个动作被用于实现布尔开关。</li>
<li>append 将值保存到一个列表中。若参数重复出现，则保存多个值。</li>
<li>append_const 将一个定义在参数规格中的值保存到一个列表中。</li>
<li>version 打印关于程序的版本信息，然后退出</li>
<li>count 记录参数出现的次数,不指定即为None</li>
</ul></li>
<li>default：参数没有赋值时，会采用默认值，必选参数除外</li>
</ul>

<h2 id="toc_4">添加解析参数</h2>

<h3 id="toc_5">添加必选参数</h3>

<p>必选参数的特点</p>

<ul>
<li>添加参数时参数名直接命名，不需要特殊符号</li>
<li>在启动文件的时候必须按照顺序赋值参数，不需要指定参数名，参数之间以空格分隔。</li>
</ul>

<p>示例代码：</p>

<pre><code class="language-python">parser.add_argument(&quot;name&quot;, help=&quot;user name&quot;)
parser.add_argument(&quot;age&quot;, type=int, choices=[1, 2, 6, 18, 24], help=&quot;user age&quot;)
print(parser.parse_args())
</code></pre>

<p>示例结果：</p>

<pre><code class="language-python">python3 argparse_test.py xiaoming 24
Namespace(age=24, name=&#39;xiaoming&#39;)
# 如果age没有不在choices中，会报以下错误：
python3 argparse_test.py xiaoming 23
usage: argparse_test.py [-h] name {1,2,6,18,24}
argparse_test.py: error: argument age: invalid choice: 23 (choose from 1, 2, 6, 18, 24)
</code></pre>

<h3 id="toc_6">添加可选参数</h3>

<p>可选参数的特点</p>

<ul>
<li>添加参数时参数名前面有两个“--”（注意不是下划线，是短线）</li>
<li>可选参数在启动文件时可以不赋值，如果参数有默认值，会选择默认值进行赋值，如果没有，则为None</li>
<li>在启动文件时不需要按照顺序执行，只需要指定参数名和参数值，以空格分隔。</li>
</ul>

<p>示例代码：</p>

<pre><code class="language-python">parser.add_argument(&quot;--name&quot;, action=&quot;store_true&quot;)
parser.add_argument(&quot;--age&quot;, action=&quot;store_const&quot;, const=&#39;this is age&#39;)
parser.add_argument(&quot;--weight1&quot;, action=&quot;count&quot;, default=0)
parser.add_argument(&quot;--weight2&quot;, action=&quot;append&quot;, type=int)
parser.add_argument(&quot;--height1&quot;, action=&quot;append_const&quot;, const=42, dest=&quot;w_h&quot;)
parser.add_argument(&quot;--height2&quot;, action=&quot;append_const&quot;, const=1, dest=&quot;w_h&quot;)
parser.add_argument(&quot;--version&quot;, action=&quot;version&quot;, version=&#39;%(prog)s 0.1&#39;)
args = parser.parse_args()
print(args)
print(args.weight1 &gt;= 0)
print(type(args.w_h))
</code></pre>

<p>示例结果</p>

<pre><code class="language-python"># name的动作决定启动时如果有--name,值为真，没有为假
python3 argparse_test.py --name
Namespace(age=None, name=True, w_h=None, weight1=0, weight2=None)
</code></pre>

<p><strong>注：可选参数可以有简写，会以&quot;-&quot;开头，后面紧接简写，如下所示</strong></p>

<pre><code class="language-python">parser.add_argument(&quot;-w&quot;, &quot;--weight&quot;, action=&quot;append&quot;, type=int)
</code></pre>

<h3 id="toc_7">混合使用必选参数和可选参数</h3>

<p>有时候在启动脚本时会有一些必选参数，也会有一些可选参数。混合使用的时候，各自特点仍然不变，顺序是可以改变的，不过必选参数因为不指定参数名，所以必选参数之间的顺序是不能调换的。</p>

<p>示例代码：</p>

<pre><code class="language-python">parser.add_argument(&quot;name&quot;, help=&quot;user name&quot;)
parser.add_argument(&quot;-a&quot;, &quot;--age&quot;, type=int, help=&quot;increase output verbosity&quot;)
parser.add_argument(&quot;-w&quot;, &quot;--weight&quot;, type=int)
parser.add_argument(&quot;tall&quot;, type=int)
parser.add_argument(&quot;hobby&quot;, type=str)
args = parser.parse_args()
print(args)
print(args.weight)
</code></pre>

<p>示例结果：</p>

<pre><code class="language-python"># 正常使用的情况：
python3 argparse_test.py xiaoming -w 287 167 hobby -a 25
Namespace(age=25, hobby=&#39;hobby&#39;, name=&#39;xiaoming&#39;, tall=167, weight=287)
287
# 如果必选参数位置改变的情况，可以看到赋值是不一样的：
python3 argparse_test.py hobby -w 287 2167  xiaoming -a 25
Namespace(age=25, hobby=&#39;xiaoming&#39;, name=&#39;hobby&#39;, tall=2167, weight=287)
287
# 如果顺序的调换导致参数类型不能对应，则会报错：
python3 argparse_test.py hobby -w 287  xiaoming -a 25 167
usage: argparse_test.py [-h] [-a AGE] [-w WEIGHT] name tall hobby
argparse_test.py: error: argument tall: invalid int value: &#39;xiaoming&#39;
</code></pre>

<h3 id="toc_8">添加参数冲突</h3>

<p>有时候会根据不同的使用场景，设置几个不同的参数，而这几个参数之间是互斥的，即有他没我，有我没他的关系，所以就用到了参数冲突。几个冲突的参数放在一个集合中，就能够保证只能出现其中的一个，如代码示例所示：</p>

<p>代码示例：</p>

<pre><code class="language-python">group = parser.add_mutually_exclusive_group()
group.add_argument(&quot;-fn&quot;, &quot;--full_name&quot;)
group.add_argument(&quot;-sn&quot;, &quot;--short_name&quot;)
parser.add_argument(&quot;-a&quot;, &quot;--age&quot;, type=int)
parser.add_argument(&quot;-w&quot;, &quot;--weight&quot;, type=int)
args = parser.parse_args()
print(args)
</code></pre>

<p>示例结果：</p>

<pre><code class="language-python"># 如果命令行参数中出现冲突，程序将会报错：
python3 argparse_test.py -fn full_name -sn short_name -a 25
usage: argparse_test.py [-h] [-fn FULL_NAME | -sn SHORT_NAME] [-a AGE]
                        [-w WEIGHT]
argparse_test.py: error: argument -sn/--short_name: not allowed with argument -fn/--full_name
# 只有当冲突参数只出现一个的时候，才能够正常执行：
python3 argparse_test.py -fn full_name -a 25
Namespace(age=25, full_name=&#39;full_name&#39;, short_name=None, weight=None)
</code></pre>

<h1 id="toc_9">请求解析☞reqparse</h1>

<h2 id="toc_10">使用背景</h2>

<p>对于一个请求中的参数，我们可以使用request.form,request.args,request.get_json()等方法将需要的数据提取出来，但是很多情况下这些数据都是不可信的，所以我们需要一一验证，在参数比较多的情况下，依次验证就显得麻烦很多，这个时候我们可以使用Flask-RESTful提供的请求解析模块——reqparse</p>

<h2 id="toc_11">定义对象</h2>

<pre><code class="language-python">from flask_restful import reqparse

parser = reqparse.RequestParser()
</code></pre>

<h2 id="toc_12">添加解析器</h2>

<pre><code class="language-python">parser.add_argument(&#39;name&#39;, type=str, default=1, required=True, ignore=True, 
location=&#39;args&#39;, choices=(&#39;bob&#39;,&#39;since&#39;), case_sensitive=False, 
store_missing=True)
</code></pre>

<p>对添加数据约束时的各个参数做一个简单的介绍：</p>

<ul>
<li>type:数据的类型，int，str，text，werkzeug.datastructures.FileStorage（files中读数据）等</li>
<li>default:如果请求中不带有该参数，则取该默认值作为参数值</li>
<li>required:值为True的情况下，规定必须包含该参数，否则报请求错误</li>
<li>ignore：值为True的情况下，如果参数类型发生转变，则会忽略该参数，即参数值为None</li>
<li>choices: 参数值在选择池中，如果不在选择池中，则报请求错误</li>
<li>case_sensitive: 值为True的情况下，会区分大小写，值为False的情况下，大写转小写</li>
<li>store_missing:个人测试好像和default配合使用才会起作用， 在没有默认值的情况下，无论该变量的值是True还是False，其数据的值都是None，在有默认值的情况下，store_missing为True时，如果请求中没有出现该参数，则存储默认值。</li>
<li>location：指明参数的位置，比如：form, args, headers, cookies, files等，需要注意的是有的位置要指明参数的类型，如果一个参数可能存在多个位置，可以以列表的形式指明location，最后的结果会先在列表指定的位置查找，找不到的话或在其他地方查找</li>
</ul>

<h2 id="toc_13">解析器继承</h2>

<p>有时候会有多个公共参数，这时候如果每个请求都写一个解析器，则可能会有很多代码是重复的，所以可以指定一个父解析器，然后去继承这个解析器。</p>

<pre><code class="language-python">from flask_restful import reqparse

parser = reqparse.RequestParser()

parser.add_argument(&#39;name&#39;, type=str)
parser.add_argument(&#39;weight&#39;, type=int, required=True)
parser.add_argument(&#39;height&#39;, type=int)

# 使用parser.copy()方法扩展parser解析器
parser_copy = parser.copy()
#添加新的参数
parser_copy.add_argument(&#39;age&#39;, type=int)
#replace_argument()方法重写某个参数的解析约束
parser_copy.replace_argument(&#39;weight&#39;, type=int)
#remove_argument()方法删除某个参数
parser_copy.remove_argument(&#39;height&#39;)
</code></pre>

<h2 id="toc_14">执行参数解析与获取参数值</h2>

<p>这里直接写参数解析，上文请参考定义对象和添加解析器</p>

<pre><code class="language-python">args = parser.parse_args()
name = args.get(&quot;name&quot;)
</code></pre>

<p><strong>注：请求解析是仿照命令行解析编写的</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python发送邮件☞smtplib]]></title>
    <link href="http://blog.yanzl.net/14696115775601.html"/>
    <updated>2016-07-27T17:26:17+08:00</updated>
    <id>http://blog.yanzl.net/14696115775601.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">简介</h2>

<p>python的smtplib模块通过对smtp协议进行封装，实现了发送电子邮件的方式</p>

<h2 id="toc_1">创建SMTP对象</h2>

<pre><code class="language-python">import smtplib

#参数依次为SMTP服务器主机，端口，主机名，都是可选参数
smtpObj = smtplib.SMTP(host, port, local_hostname)
</code></pre>

<h2 id="toc_2">发送邮件</h2>

<pre><code class="language-python">#可以看出，msg是发送的邮件，包含了标题，收件人，发件人，邮件内容，有时还会有附件，msg的格式必须是smtp协议中定义的格式
smtpObj.sendmail(from_addr, to_addr, msg)
</code></pre>

<h2 id="toc_3">发送文本消息的邮件</h2>

<p>这里接着上面的代码继续写，对没有的部分进行补充。</p>

<pre><code class="language-python">from email.mime.text import MIMEText
from email.header import Header

#如果使用的是本地邮件服务，这里可以不用登录
smtpObj.login(‘服务器用户名’, ‘用户名密码’)
#添加邮件消息,三个参数，文本内容，文本格式（如果是html类型，这里要写html），设置编码
msg = MIMEText(‘this is test email’, ‘plain’, ‘utf-8’)
#添加发件人，收件人，主题
msg[&quot;Form&quot;] = &quot;发件人邮箱&lt;test@test.com&gt;&quot;
msg[&quot;To&quot;] = &quot;收件人邮箱&lt;receiver@receiver.com&gt;&quot;
msg[&quot;Subject&quot;] = Header(&quot;这里是标题&quot;， &quot;utf-8&quot;).encode()

#发送
smtpObj.sendmail(&quot;发送者邮箱&quot;, [接受者邮箱，是列表类型，可以有多个接受者], msg.as_string())
</code></pre>

<h2 id="toc_4">发送带附件的邮件</h2>

<p>这里直接写与发送文本消息不同的部分，和发送文本消息不同的部分是消息对象的创建不是MIMEText，而是MIMEMultipart，添加邮件消息采用attach()方法</p>

<pre><code class="language-python">from email.mime.multipart import MIMEMultipart
#创建消息对象
msg = MIMEMultipart()

#添加邮件消息
msg.attach(MIMEText(&quot;this is test email&quot;, &quot;plain&quot;, &quot;utf-8&quot;))

#构造附件
att1 = MIMEText(open(&#39;test.txt&#39;, &#39;rb&#39;).read(), &#39;base64&#39;, &#39;utf-8&#39;)
att1[&quot;Content-Type&quot;] = &#39;application/octet-stream&#39;
# 这里的filename可以任意写，写什么名字，邮件中显示什么名字
att1[&quot;Content-Disposition&quot;] = &#39;attachment; filename=&quot;test.txt&quot;&#39;
msg.attach(att1)
#可以使用此方法添加多个附件

#发送,和发送文本邮件相同
smtpObj.sendmail(&quot;发送者邮箱&quot;, [接受者邮箱，是列表类型，可以有多个接受者], msg.as_string())
</code></pre>

<h2 id="toc_5">扩展☞HTML类型的邮件内容中显示图片</h2>

<p>这里直接上一个完整的例子</p>

<pre><code class="language-python">import smtplib
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.header import Header

sender = &quot;发送者邮箱&quot;
receivers = &quot;接收者列表&quot; # 接收邮件，可设置为你的QQ邮箱或者其他邮箱

msg = MIMEMultipart(&#39;related&#39;)
msg[&#39;From&#39;] = Header(&quot;发送者信息&quot;, &#39;utf-8&#39;)
msg[&#39;To&#39;] =  Header(&quot;接收者信息&quot;, &#39;utf-8&#39;)
msg[&#39;Subject&#39;] = Header(&quot;Python SMTP 邮件测试&quot;, &#39;utf-8&#39;)

msgAlternative = MIMEMultipart(&#39;alternative&#39;)
msg.attach(msgAlternative)


mail_msg = &quot;&quot;&quot;
&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;则是超链接地址&quot;&gt;这是一个超链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图片演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;cid:image1&quot;&gt;&lt;/p&gt;
&quot;&quot;&quot;
msgAlternative.attach(MIMEText(mail_msg, &#39;html&#39;, &#39;utf-8&#39;))

# 指定图片为当前目录
fp = open(&#39;test.png&#39;, &#39;rb&#39;)
msgImage = MIMEImage(fp.read())
fp.close()

# 定义图片 ID，在 HTML 文本中引用
msgImage.add_header(&#39;Content-ID&#39;, &#39;&lt;image1&gt;&#39;)
msg.attach(msgImage)

#在本机有邮件服务的情况下进行发送
smtpObj = smtplib.SMTP(&#39;localhost&#39;)
smtpObj.sendmail(sender, receivers, msg.as_string())

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python发送邮件☞flask-mail扩展]]></title>
    <link href="http://blog.yanzl.net/14690965374529.html"/>
    <updated>2016-07-21T18:22:17+08:00</updated>
    <id>http://blog.yanzl.net/14690965374529.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">简介</h2>

<p>Python的扩展库，采用SMTP协议完成邮件的发送，需要自己安装。</p>

<h2 id="toc_1">安装方法</h2>

<p>一种方法是通过pip进行安装</p>

<pre><code class="language-python">pip install Flask-Mail
</code></pre>

<p>另一种方法是下载源码，通过python解释安装</p>

<pre><code class="language-python">python setup.py install
</code></pre>

<h2 id="toc_2">选项配置</h2>

<p>通过配置，可以指定邮件发送的参数选项</p>

<pre><code>MAIL_SERVER: SMTP服务器主机，可以指定主机IP地址，也可以是域名
MAIL_PORT: SMTP服务使用的端口号，一般会是25
MAIL_USERNAME:登录服务器的账号名
MAIL_PASSWORD:登录服务器的密码
MAIL_DEFAULT_SENDER:默认发送方
MAIL_MAX_EMAILS:支持一次连接时最大发送邮件数目，默认会是None，即无限制
</code></pre>

<h2 id="toc_3">创建邮件发送实例</h2>

<pre><code class="language-python">from flask import Flask
from flask_mail import Mail

app = Flask(__name__)
mail = Mail()
mail.init_app(app)#使用Flask的current_app中的配置项进行发送
</code></pre>

<h2 id="toc_4">创建文本文件内容</h2>

<pre><code class="language-python">from flask.ext.mail import Message
#创建消息对象，参数依次为标题，发送方（如果配置中有默认发送方，这里可以不写.另外，sender可以是一个二元组，代表姓名和邮件地址），接收方（列表类型，可以有多个接收者）
msg = Message(&#39;title&#39;, sender=([sender_name], sender_email), recipients=receivers)
#可以通过add_recipient()方法添加接收者
msg.add_recipient(&quot;new_email@email.com&quot;)
msg.body = &quot;这里是邮件体，即要发送的邮件的内容&quot;
msg.html = &quot;如果是html格式，使用html属性进行添加邮件体&quot;
</code></pre>

<h2 id="toc_5">创建带有附件的邮件内容</h2>

<pre><code class="language-python">from ××× import app
with app.open_resource(&quot;附件路径&quot;) as fp:
    msg.attach(&quot;附件名，可更换&quot;, &quot;附件类型&quot;, fp.read())
#附件类型这里可以说一下，博主一共用到了两种类型，一种是图片：image/png;另一种是文件：application/octet-stream；如有问题，欢迎更正，如要添加，更是欢迎！！
</code></pre>

<h2 id="toc_6">直接发送邮件</h2>

<pre><code class="language-python">mail.send(msg)
</code></pre>

<h2 id="toc_7">扩展☞发送大量邮件</h2>

<p>有时候会向多人发送邮件，并且邮件的内容会稍有不同，比如称呼什么的，这时候可以采用以下方式进行发送</p>

<pre><code class="language-python">with mail.connect() as conn:
    for user in users:
        message = &quot;.....一堆邮件body&quot;
        subject = &quot;hello, {}&quot;.format(user.name)
        msg = Message(recipients=user.email,body=message, subject=subject)
        conn.send(msg)
</code></pre>

<p>参考文档：<a href="https://pythonhosted.org/Flask-Mail/">Flask-Mail</a></p>

]]></content>
  </entry>
  
</feed>
